var documenterSearchIndex = {"docs":
[{"location":"#ParametricDFT","page":"Home","title":"ParametricDFT","text":"Documentation for ParametricDFT.\n\n","category":"section"},{"location":"#ParametricDFT.AbstractLoss","page":"Home","title":"ParametricDFT.AbstractLoss","text":"AbstractLoss\n\nAbstract base type for loss functions. Custom loss functions should inherit from  this type and implement _loss_function(fft_result, input, loss).\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.L1Norm","page":"Home","title":"ParametricDFT.L1Norm","text":"L1Norm <: AbstractLoss\n\nL1 norm loss: minimizes sum of absolute values in the transformed domain. This encourages sparsity in the frequency representation.\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.L2Norm","page":"Home","title":"ParametricDFT.L2Norm","text":"L2Norm <: AbstractLoss\n\nL2 norm loss: minimizes sum of squared magnitudes in the transformed domain. This encourages energy concentration (squared magnitude) with smoother gradients compared to L1 norm, and less aggressive sparsity promotion than L1.\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.MSELoss","page":"Home","title":"ParametricDFT.MSELoss","text":"MSELoss <: AbstractLoss\n\nMean Squared Error loss with truncation: minimizes reconstruction error after forward transform, truncation (keeping top k elements), and inverse transform.\n\nFields\n\nk::Int: Number of top elements to keep after truncation (by magnitude)\n\nEquation\n\nL(θ) = Σᵢ ||xᵢ - T(θ)⁻¹(truncate(T(θ)(xᵢ), k))||²₂\n\nThis loss encourages the circuit to learn a representation where the top k frequency components capture most of the signal information.\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.fft_with_training-Tuple{Int64, Int64, Matrix, AbstractLoss}","page":"Home","title":"ParametricDFT.fft_with_training","text":"fft_with_training(m::Int, n::Int, pic::Matrix, loss::AbstractLoss; steps::Int=1000, use_cuda::Bool=false)\n\nTrain a parametric 2D quantum DFT circuit using Riemannian gradient descent.\n\nArguments\n\nm::Int: Number of qubits for row dimension (image height = 2^m)\nn::Int: Number of qubits for column dimension (image width = 2^n)\npic::Matrix: Input signal (size must be 2^m × 2^n)\nloss::AbstractLoss: Loss function (e.g., L1Norm())\nsteps::Int=1000: Maximum optimization iterations\nuse_cuda::Bool=false: Whether to use CUDA acceleration (not yet implemented)\n\nReturns\n\nOptimized parameters on the manifold (use point2tensors to convert to tensors)\n\nExample\n\nm, n = 6, 6  # For 64×64 image\npic = rand(ComplexF64, 2^m, 2^n)\n# L1 norm loss\ntheta = fft_with_training(m, n, pic, L1Norm(); steps=200)\n# MSE loss with truncation (keep top 100 elements)\ntheta = fft_with_training(m, n, pic, MSELoss(100); steps=200)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.ft_mat-Tuple{Vector, OMEinsum.AbstractEinsum, Int64, Int64, Matrix}","page":"Home","title":"ParametricDFT.ft_mat","text":"ft_mat(tensors::Vector, code::AbstractEinsum, m::Int, n::Int, pic::Matrix)\n\nApply 2D DFT to an image using the trained circuit parameters.\n\nArguments\n\ntensors::Vector: Circuit tensors (unitary matrices)\ncode::AbstractEinsum: Optimized einsum code\nm::Int: Number of qubits for row dimension\nn::Int: Number of qubits for column dimension\npic::Matrix: Input image (size 2^m × 2^n)\n\nReturns\n\nTransformed image in frequency domain (size 2^m × 2^n)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.generate_manifold-Tuple{Any}","page":"Home","title":"ParametricDFT.generate_manifold","text":"generate_manifold(tensors)\n\nGenerate product manifold for m+n-qubit QFT parameters. Returns a product of U(2) manifolds for Hadamard gates and U(1)^4 for controlled gates.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.ift_mat-Tuple{Vector, OMEinsum.AbstractEinsum, Int64, Int64, Matrix}","page":"Home","title":"ParametricDFT.ift_mat","text":"ift_mat(tensors::Vector, code::AbstractEinsum, m::Int, n::Int, pic::Matrix)\n\nApply inverse 2D DFT using the inverse QFT circuit with trained parameters.\n\nArguments\n\ntensors::Vector: Circuit tensors (unitary matrices) from inverse QFT (use qft_code(m, n; inverse=true))\ncode::AbstractEinsum: Optimized einsum code from inverse QFT\nm::Int: Number of qubits for row dimension\nn::Int: Number of qubits for column dimension\npic::Matrix: Input in frequency domain (size 2^m × 2^n)\n\nReturns\n\nTransformed image in spatial domain (size 2^m × 2^n)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.loss_function-Tuple{AbstractVector, Int64, Int64, OMEinsum.AbstractEinsum, Matrix, AbstractLoss}","page":"Home","title":"ParametricDFT.loss_function","text":"loss_function(tensors, m::Int, n::Int, optcode::AbstractEinsum, pic::Matrix, loss::AbstractLoss; inverse_code=nothing)\n\nCompute the loss for current circuit parameters.\n\nArguments\n\ntensors::Vector: Circuit parameters (unitary matrices)\nm::Int: Number of qubits for row dimension\nn::Int: Number of qubits for column dimension\noptcode::AbstractEinsum: Optimized einsum code (forward transform)\npic::Matrix: Input signal (size must be 2^m × 2^n)\nloss::AbstractLoss: Loss function type\ninverse_code::AbstractEinsum: Optional inverse einsum code (required for MSELoss)\n\nReturns\n\nLoss value\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.point2tensors-Tuple{Any, Any}","page":"Home","title":"ParametricDFT.point2tensors","text":"point2tensors(p, M)\n\nConvert a manifold point back to circuit tensors (unitary matrices).\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.qft_code-Tuple{Int64, Int64}","page":"Home","title":"ParametricDFT.qft_code","text":"qft_code(m::Int, n::Int)\n\nGenerate an optimized tensor network representation of the QFT circuit.\n\nArguments\n\nm::Int: Number of qubits for row indices\nn::Int: Number of qubits for column indices\n\nReturns\n\noptcode::AbstractEinsum: Optimized einsum contraction code\ntensors::Vector: Initial circuit parameters (unitary matrices)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.tensors2point-Tuple{Any, ManifoldsBase.ProductManifold}","page":"Home","title":"ParametricDFT.tensors2point","text":"tensors2point(tensors, M::ProductManifold)\n\nConvert circuit tensors (unitary matrices) to a point on the product manifold.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.topk_truncate-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer}} where T","page":"Home","title":"ParametricDFT.topk_truncate","text":"topk_truncate(x::AbstractMatrix, k::Integer)\n\nReturn a matrix where frequency-dependent truncation is applied for image compression. Low-frequency components (near center) are kept with higher priority, while high-frequency components (away from center) are kept with lower priority.\n\nThis is more appropriate for image compression than global top-k selection, as it preserves more low-frequency information which contains most of the image structure.\n\n\n\n\n\n","category":"method"}]
}
