var documenterSearchIndex = {"docs":
[{"location":"#ParametricDFT","page":"Home","title":"ParametricDFT","text":"Documentation for ParametricDFT.\n\n","category":"section"},{"location":"#ParametricDFT.AbstractLoss","page":"Home","title":"ParametricDFT.AbstractLoss","text":"AbstractLoss\n\nAbstract base type for loss functions. Custom loss functions should inherit from  this type and implement _loss_function(fft_result, input, loss).\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.AbstractSparseBasis","page":"Home","title":"ParametricDFT.AbstractSparseBasis","text":"AbstractSparseBasis\n\nAbstract base type for sparse basis representations. All concrete basis types should inherit from this and implement the required interface:\n\nRequired methods:\n\nforward_transform(basis, image) - transform image to frequency domain\ninverse_transform(basis, freq_domain) - inverse transform\nimage_size(basis) - return supported image dimensions\nnum_parameters(basis) - return total parameter count\nbasis_hash(basis) - return unique hash for basis identification\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.BasisJSON","page":"Home","title":"ParametricDFT.BasisJSON","text":"BasisJSON\n\nInternal struct for JSON serialization of QFTBasis.\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.CompressedImage","page":"Home","title":"ParametricDFT.CompressedImage","text":"CompressedImage\n\nSparse representation of an image in the frequency domain.\n\nFields\n\nindices::Vector{Int}: Linear indices of non-zero coefficients\nvalues_real::Vector{Float64}: Real parts of coefficient values\nvalues_imag::Vector{Float64}: Imaginary parts of coefficient values\noriginal_size::Tuple{Int,Int}: Original image dimensions (height, width)\nbasis_hash::String: Hash of the basis used for compression (for verification)\n\nNote\n\nThe compressed representation stores only the non-zero coefficients after truncation, achieving compression by discarding small coefficients.\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.CompressedImageJSON","page":"Home","title":"ParametricDFT.CompressedImageJSON","text":"CompressedImageJSON\n\nInternal struct for JSON serialization of CompressedImage.\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.EntangledBasisJSON","page":"Home","title":"ParametricDFT.EntangledBasisJSON","text":"EntangledBasisJSON\n\nInternal struct for JSON serialization of EntangledQFTBasis.\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.EntangledQFTBasis","page":"Home","title":"ParametricDFT.EntangledQFTBasis","text":"EntangledQFTBasis <: AbstractSparseBasis\n\nEntangled Quantum Fourier Transform basis with XY correlation.\n\nThis basis extends the standard QFT by adding entanglement gates E_k between corresponding row and column qubits. Each entanglement gate has the same form as the M gate in QFT:\n\nE_k = diag(1, 1, 1, e^(i*phi_k))\n\nacting on qubits (x{n-k}, y{n-k}), where phi_k is a learnable phase parameter.\n\nFields\n\nm::Int: Number of qubits for row dimension (image height = 2^m)\nn::Int: Number of qubits for column dimension (image width = 2^n)\ntensors::Vector: Circuit parameters (unitary matrices + entanglement gates)\noptcode::AbstractEinsum: Optimized einsum code for forward transform\ninverse_code::AbstractEinsum: Optimized einsum code for inverse transform\nn_entangle::Int: Number of entanglement gates (= min(m, n))\nentangle_phases::Vector{Float64}: Phase parameters for entanglement gates\n\nExample\n\n# Create default entangled QFT basis for 64×64 images\nbasis = EntangledQFTBasis(6, 6)\n\n# Create with custom initial entanglement phases\nphases = rand(6) * 2π\nbasis = EntangledQFTBasis(6, 6; entangle_phases=phases)\n\n# Transform an image\nfreq = forward_transform(basis, image)\n\n# Inverse transform\nreconstructed = inverse_transform(basis, freq)\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.EntangledQFTBasis-Tuple{Int64, Int64, Vector, Int64}","page":"Home","title":"ParametricDFT.EntangledQFTBasis","text":"EntangledQFTBasis(m::Int, n::Int, tensors::Vector, n_entangle::Int)\n\nConstruct an EntangledQFTBasis with custom trained tensors.\n\nArguments\n\nm::Int: Number of qubits for rows\nn::Int: Number of qubits for columns\ntensors::Vector: Pre-trained circuit parameters\nn_entangle::Int: Number of entanglement gates\n\nReturns\n\nEntangledQFTBasis: Basis with custom parameters\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.EntangledQFTBasis-Tuple{Int64, Int64}","page":"Home","title":"ParametricDFT.EntangledQFTBasis","text":"EntangledQFTBasis(m::Int, n::Int; entangle_phases=nothing)\n\nConstruct an EntangledQFTBasis with default or custom entanglement phases.\n\nArguments\n\nm::Int: Number of qubits for rows (image height = 2^m)\nn::Int: Number of qubits for columns (image width = 2^n)\nentangle_phases::Union{Nothing, Vector{<:Real}}: Initial phases for entanglement gates. If nothing, defaults to zeros (equivalent to standard QFT initially).\n\nReturns\n\nEntangledQFTBasis: Basis with entangled QFT circuit parameters\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.L1Norm","page":"Home","title":"ParametricDFT.L1Norm","text":"L1Norm <: AbstractLoss\n\nL1 norm loss: minimizes sum of absolute values in the transformed domain. This encourages sparsity in the frequency representation.\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.L2Norm","page":"Home","title":"ParametricDFT.L2Norm","text":"L2Norm <: AbstractLoss\n\nL2 norm loss: minimizes sum of squared magnitudes in the transformed domain. This encourages energy concentration (squared magnitude) with smoother gradients compared to L1 norm, and less aggressive sparsity promotion than L1.\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.MSELoss","page":"Home","title":"ParametricDFT.MSELoss","text":"MSELoss <: AbstractLoss\n\nMean Squared Error loss with truncation: minimizes reconstruction error after forward transform, truncation (keeping top k elements), and inverse transform.\n\nFields\n\nk::Int: Number of top elements to keep after truncation (by magnitude)\n\nEquation\n\nL(θ) = Σᵢ ||xᵢ - T(θ)⁻¹(truncate(T(θ)(xᵢ), k))||²₂\n\nThis loss encourages the circuit to learn a representation where the top k frequency components capture most of the signal information.\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.QFTBasis","page":"Home","title":"ParametricDFT.QFTBasis","text":"QFTBasis <: AbstractSparseBasis\n\nQuantum Fourier Transform basis using tensor network representation.\n\nFields\n\nm::Int: Number of qubits for row dimension (image height = 2^m)\nn::Int: Number of qubits for column dimension (image width = 2^n)\ntensors::Vector: Circuit parameters (unitary matrices)\noptcode::AbstractEinsum: Optimized einsum code for forward transform\ninverse_code::AbstractEinsum: Optimized einsum code for inverse transform\n\nExample\n\n# Create default QFT basis for 64×64 images\nbasis = QFTBasis(6, 6)\n\n# Transform an image\nfreq = forward_transform(basis, image)\n\n# Inverse transform\nreconstructed = inverse_transform(basis, freq)\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.QFTBasis-Tuple{Int64, Int64, Vector}","page":"Home","title":"ParametricDFT.QFTBasis","text":"QFTBasis(m::Int, n::Int, tensors::Vector)\n\nConstruct a QFTBasis with custom trained tensors.\n\nArguments\n\nm::Int: Number of qubits for rows\nn::Int: Number of qubits for columns\ntensors::Vector: Pre-trained circuit parameters\n\nReturns\n\nQFTBasis: Basis with custom parameters\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.QFTBasis-Tuple{Int64, Int64}","page":"Home","title":"ParametricDFT.QFTBasis","text":"QFTBasis(m::Int, n::Int)\n\nConstruct a QFTBasis with default QFT circuit parameters.\n\nArguments\n\nm::Int: Number of qubits for rows (image height = 2^m)\nn::Int: Number of qubits for columns (image width = 2^n)\n\nReturns\n\nQFTBasis: Basis with standard QFT circuit parameters\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{EntangledQFTBasis, EntangledQFTBasis}","page":"Home","title":"Base.:==","text":"Base.:(==)(a::EntangledQFTBasis, b::EntangledQFTBasis)\n\nCheck equality of two EntangledQFTBasis objects.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{QFTBasis, QFTBasis}","page":"Home","title":"Base.:==","text":"Base.:(==)(a::QFTBasis, b::QFTBasis)\n\nCheck equality of two QFTBasis objects.\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO, CompressedImage}","page":"Home","title":"Base.show","text":"Base.show(io::IO, compressed::CompressedImage)\n\nPretty print the CompressedImage.\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO, EntangledQFTBasis}","page":"Home","title":"Base.show","text":"Base.show(io::IO, basis::EntangledQFTBasis)\n\nPretty print the EntangledQFTBasis.\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO, QFTBasis}","page":"Home","title":"Base.show","text":"Base.show(io::IO, basis::QFTBasis)\n\nPretty print the QFTBasis.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT._basis_to_json-Tuple{EntangledQFTBasis}","page":"Home","title":"ParametricDFT._basis_to_json","text":"_basis_to_json(basis::EntangledQFTBasis)\n\nConvert an EntangledQFTBasis to JSON-serializable format.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT._basis_to_json-Tuple{QFTBasis}","page":"Home","title":"ParametricDFT._basis_to_json","text":"_basis_to_json(basis::QFTBasis)\n\nConvert a QFTBasis to JSON-serializable format.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT._compute_basis_loss-Tuple{AbstractMatrix, Vector, OMEinsum.AbstractEinsum, OMEinsum.AbstractEinsum, Int64, Int64, AbstractLoss}","page":"Home","title":"ParametricDFT._compute_basis_loss","text":"_compute_basis_loss(img_matrix, tensors, optcode, inverse_code, m, n, loss)\n\nCompute loss for a single image given current tensors.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT._compute_validation_loss-Tuple{Vector{<:AbstractMatrix}, Vector, OMEinsum.AbstractEinsum, OMEinsum.AbstractEinsum, Int64, Int64, AbstractLoss}","page":"Home","title":"ParametricDFT._compute_validation_loss","text":"_compute_validation_loss(validation_data, tensors, optcode, inverse_code, m, n, loss)\n\nCompute average loss over validation set.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT._json_to_basis-Tuple{ParametricDFT.BasisJSON}","page":"Home","title":"ParametricDFT._json_to_basis","text":"_json_to_basis(json_data::BasisJSON)\n\nConvert JSON data back to a QFTBasis object.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT._json_to_entangled_basis-Tuple{ParametricDFT.EntangledBasisJSON}","page":"Home","title":"ParametricDFT._json_to_entangled_basis","text":"_json_to_entangled_basis(json_data::EntangledBasisJSON)\n\nConvert JSON data back to an EntangledQFTBasis object.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT._reconstruct_frequency_domain-Tuple{CompressedImage, Tuple{Int64, Int64}}","page":"Home","title":"ParametricDFT._reconstruct_frequency_domain","text":"_reconstruct_frequency_domain(compressed::CompressedImage, size::Tuple{Int,Int})\n\nReconstruct full frequency domain matrix from sparse representation.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT._select_top_coefficients-Tuple{AbstractMatrix, Int64}","page":"Home","title":"ParametricDFT._select_top_coefficients","text":"_select_top_coefficients(freq_domain::AbstractMatrix, k::Int)\n\nSelect top k coefficients using frequency-weighted magnitude scoring.\n\nLow-frequency components (near center) are prioritized as they typically contain more important structural information.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT._train_on_single_image-Tuple{AbstractMatrix, Any, ManifoldsBase.ProductManifold, OMEinsum.AbstractEinsum, OMEinsum.AbstractEinsum, Int64, Int64, AbstractLoss, Int64}","page":"Home","title":"ParametricDFT._train_on_single_image","text":"_train_on_single_image(img_matrix, theta, M, optcode, inverse_code, m, n, loss, steps)\n\nTrain on a single image using gradient descent.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.basis_hash-Tuple{EntangledQFTBasis}","page":"Home","title":"ParametricDFT.basis_hash","text":"basis_hash(basis::EntangledQFTBasis)\n\nCompute a unique hash identifying this basis configuration and parameters.\n\nReturns\n\nString: SHA-256 hash of the basis parameters\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.basis_hash-Tuple{QFTBasis}","page":"Home","title":"ParametricDFT.basis_hash","text":"basis_hash(basis::QFTBasis)\n\nCompute a unique hash identifying this basis configuration and parameters.\n\nReturns\n\nString: SHA-256 hash of the basis parameters\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.basis_to_dict-Tuple{EntangledQFTBasis}","page":"Home","title":"ParametricDFT.basis_to_dict","text":"basis_to_dict(basis::EntangledQFTBasis) -> Dict\n\nConvert an EntangledQFTBasis to a dictionary for custom serialization.\n\nReturns\n\nDict: Dictionary representation of the basis\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.basis_to_dict-Tuple{QFTBasis}","page":"Home","title":"ParametricDFT.basis_to_dict","text":"basis_to_dict(basis::AbstractSparseBasis) -> Dict\n\nConvert a basis to a dictionary for custom serialization.\n\nReturns\n\nDict: Dictionary representation of the basis\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.compress-Tuple{AbstractSparseBasis, AbstractMatrix}","page":"Home","title":"ParametricDFT.compress","text":"compress(basis::AbstractSparseBasis, image::AbstractMatrix; ratio::Float64=0.9)\n\nCompress an image using the given sparse basis.\n\nArguments\n\nbasis::AbstractSparseBasis: The trained basis to use for compression\nimage::AbstractMatrix: Input image (must match basis dimensions)\nratio::Float64 = 0.9: Compression ratio (0.9 means keep only 10% of coefficients)\n\nReturns\n\nCompressedImage: Sparse representation of the image\n\nExample\n\nbasis = load_basis(\"trained_basis.json\")\nimage = load_grayscale_image(\"photo.png\")\ncompressed = compress(basis, image; ratio=0.95)  # Keep top 5%\nsave_compressed(\"photo.cimg\", compressed)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.compress_with_k-Tuple{AbstractSparseBasis, AbstractMatrix}","page":"Home","title":"ParametricDFT.compress_with_k","text":"compress_with_k(basis::AbstractSparseBasis, image::AbstractMatrix; k::Int)\n\nCompress an image keeping exactly k coefficients.\n\nArguments\n\nbasis::AbstractSparseBasis: The trained basis to use\nimage::AbstractMatrix: Input image\nk::Int: Exact number of coefficients to keep\n\nReturns\n\nCompressedImage: Sparse representation\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.compression_stats-Tuple{CompressedImage}","page":"Home","title":"ParametricDFT.compression_stats","text":"compression_stats(compressed::CompressedImage) -> NamedTuple\n\nGet statistics about the compression.\n\nReturns\n\nA named tuple with:\n\noriginal_size: Original image dimensions\ntotal_coefficients: Total number of coefficients\nkept_coefficients: Number of non-zero coefficients kept\ncompression_ratio: Ratio of discarded coefficients\nstorage_reduction: Approximate storage reduction factor\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.dict_to_basis-Tuple{Dict}","page":"Home","title":"ParametricDFT.dict_to_basis","text":"dict_to_basis(d::Dict) -> AbstractSparseBasis\n\nConvert a dictionary back to a basis.\n\nArguments\n\nd::Dict: Dictionary with basis data\n\nReturns\n\nAbstractSparseBasis: The reconstructed basis\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.entangled_qft_code-Tuple{Int64, Int64}","page":"Home","title":"ParametricDFT.entangled_qft_code","text":"entangled_qft_code(m::Int, n::Int; entangle_phases=nothing, inverse=false)\n\nGenerate an optimized tensor network representation of the entangled QFT circuit.\n\nThe entangled QFT extends the standard 2D QFT by adding entanglement gates Ek between corresponding row and column qubits (xk, yk). Each entanglement gate Ek is a controlled-phase gate with the same structure as the M gate in QFT:\n\nFull gate form (4×4 matrix):     Ek = diag(1, 1, 1, e^(i*phik))\n\nTensor network form (2×2 matrix):     Ektensor = [1 0; 0 e^(i*phi_k)]\n\nThe gate acts on qubits (x{n-k}, y{n-k}), where phi_k is a learnable phase parameter. In the tensor network, these are represented as 2×2 matrices.\n\nFor a square 2^n × 2^n image (m = n), we add exactly n entanglement gates, one for each pair of corresponding row/column qubits.\n\nArguments\n\nm::Int: Number of qubits for row indices (image height = 2^m)\nn::Int: Number of qubits for column indices (image width = 2^n)\nentangle_phases::Union{Nothing, Vector{<:Real}}: Initial phases for entanglement gates. If nothing, defaults to zeros (equivalent to standard QFT). Length must equal min(m, n).\ninverse::Bool: If true, generate inverse transform code\n\nReturns\n\noptcode::AbstractEinsum: Optimized einsum contraction code\ntensors::Vector: Circuit parameters (unitary matrices + entanglement gates)\nn_entangle::Int: Number of entanglement gates added\n\nExample\n\n# Create entangled QFT for 64×64 images with default (zero) phases\noptcode, tensors, n_entangle = entangled_qft_code(6, 6)\n\n# Create with custom initial phases\nphases = rand(6) * 2π\noptcode, tensors, n_entangle = entangled_qft_code(6, 6; entangle_phases=phases)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.entanglement_gate-Tuple{Real}","page":"Home","title":"ParametricDFT.entanglement_gate","text":"entanglement_gate(phi::Real)\n\nCreate the tensor network representation of a 2-qubit controlled-phase gate E with learnable phase phi.\n\nFull gate form (4×4 matrix in computational basis):     E = diag(1, 1, 1, e^(i*phi))\n\nThis applies phase e^(i*phi) only when both qubits are in state |1⟩.\n\nTensor network form (2×2 matrix):     E_tensor = [1  0; 0  e^(i*phi)]\n\nIn the einsum tensor network decomposition, controlled-phase gates are  represented as 2×2 matrices acting on the bond indices connecting the  control and target qubits. This function returns the tensor form, not  the full 4×4 gate matrix.\n\nThis gate has the same structure as the M gate in the QFT circuit, but with a learnable phase parameter instead of the fixed QFT phases (2π/2^k).\n\nArguments\n\nphi::Real: Phase parameter (in radians)\n\nReturns\n\nMatrix{ComplexF64}: 2×2 matrix in tensor network form\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.extract_entangle_phases-Tuple{Any, Vector{Int64}}","page":"Home","title":"ParametricDFT.extract_entangle_phases","text":"extract_entangle_phases(tensors, entangle_indices::Vector{Int})\n\nExtract the phase parameters from entanglement gate tensors.\n\nArguments\n\ntensors::Vector: Circuit tensors\nentangle_indices::Vector{Int}: Indices of entanglement gates\n\nReturns\n\nVector{Float64}: Phase parameters phi_k for each entanglement gate\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.fft_with_training-Tuple{Int64, Int64, Matrix, AbstractLoss}","page":"Home","title":"ParametricDFT.fft_with_training","text":"fft_with_training(m::Int, n::Int, pic::Matrix, loss::AbstractLoss; steps::Int=1000, use_cuda::Bool=false)\n\nTrain a parametric 2D quantum DFT circuit using Riemannian gradient descent.\n\nArguments\n\nm::Int: Number of qubits for row dimension (image height = 2^m)\nn::Int: Number of qubits for column dimension (image width = 2^n)\npic::Matrix: Input signal (size must be 2^m × 2^n)\nloss::AbstractLoss: Loss function (e.g., L1Norm())\nsteps::Int=1000: Maximum optimization iterations\nuse_cuda::Bool=false: Whether to use CUDA acceleration (not yet implemented)\n\nReturns\n\nOptimized parameters on the manifold (use point2tensors to convert to tensors)\n\nExample\n\nm, n = 6, 6  # For 64×64 image\npic = rand(ComplexF64, 2^m, 2^n)\n# L1 norm loss\ntheta = fft_with_training(m, n, pic, L1Norm(); steps=200)\n# MSE loss with truncation (keep top 100 elements)\ntheta = fft_with_training(m, n, pic, MSELoss(100); steps=200)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.forward_transform-Tuple{EntangledQFTBasis, AbstractMatrix}","page":"Home","title":"ParametricDFT.forward_transform","text":"forward_transform(basis::EntangledQFTBasis, image::AbstractMatrix)\n\nApply forward entangled QFT transform to convert image to frequency domain.\n\nArguments\n\nbasis::EntangledQFTBasis: The basis to use for transformation\nimage::AbstractMatrix: Input image (must be size 2^m × 2^n)\n\nReturns\n\nFrequency domain representation (Complex matrix of same size)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.forward_transform-Tuple{QFTBasis, AbstractMatrix}","page":"Home","title":"ParametricDFT.forward_transform","text":"forward_transform(basis::QFTBasis, image::AbstractMatrix)\n\nApply forward transform to convert image to frequency domain.\n\nArguments\n\nbasis::QFTBasis: The basis to use for transformation\nimage::AbstractMatrix: Input image (must be size 2^m × 2^n)\n\nReturns\n\nFrequency domain representation (Complex matrix of same size)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.ft_mat-Tuple{Vector, OMEinsum.AbstractEinsum, Int64, Int64, Matrix}","page":"Home","title":"ParametricDFT.ft_mat","text":"ft_mat(tensors::Vector, code::AbstractEinsum, m::Int, n::Int, pic::Matrix)\n\nApply 2D DFT to an image using the trained circuit parameters.\n\nArguments\n\ntensors::Vector: Circuit tensors (unitary matrices)\ncode::AbstractEinsum: Optimized einsum code\nm::Int: Number of qubits for row dimension\nn::Int: Number of qubits for column dimension\npic::Matrix: Input image (size 2^m × 2^n)\n\nReturns\n\nTransformed image in frequency domain (size 2^m × 2^n)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.generate_manifold-Tuple{Any}","page":"Home","title":"ParametricDFT.generate_manifold","text":"generate_manifold(tensors)\n\nGenerate product manifold for m+n-qubit QFT parameters. Returns a product of U(2) manifolds for Hadamard gates and U(1)^4 for controlled gates.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.get_entangle_phases-Tuple{EntangledQFTBasis}","page":"Home","title":"ParametricDFT.get_entangle_phases","text":"get_entangle_phases(basis::EntangledQFTBasis)\n\nGet the current entanglement phase parameters.\n\nReturns\n\nVector{Float64}: Phase parameters phi_k for each entanglement gate\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.get_entangle_tensor_indices-Tuple{Any, Int64}","page":"Home","title":"ParametricDFT.get_entangle_tensor_indices","text":"get_entangle_tensor_indices(tensors, n_entangle::Int)\n\nIdentify which tensors in the circuit correspond to entanglement gates. Returns the indices of the entanglement gate tensors (the last n_entangle controlled-phase gates).\n\nIn the tensor network representation from yao2einsum, controlled-phase gates have the form [1, 1; 1, e^(i*phi)] (not diagonal). The entanglement gates are the last n_entangle such tensors after sorting (Hadamards first, then phase gates).\n\nAfter training, tensors may drift slightly from the exact pattern, so we use tolerance-based magnitude checks.\n\nArguments\n\ntensors::Vector: Circuit tensors\nn_entangle::Int: Number of entanglement gates\n\nReturns\n\nVector{Int}: Indices of entanglement gate tensors\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.get_manifold-Tuple{EntangledQFTBasis}","page":"Home","title":"ParametricDFT.get_manifold","text":"get_manifold(basis::EntangledQFTBasis)\n\nGet the product manifold for Riemannian optimization of basis parameters.\n\nReturns\n\nProductManifold: Manifold structure for the tensors\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.get_manifold-Tuple{QFTBasis}","page":"Home","title":"ParametricDFT.get_manifold","text":"get_manifold(basis::QFTBasis)\n\nGet the product manifold for Riemannian optimization of basis parameters.\n\nReturns\n\nProductManifold: Manifold structure for the tensors\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.ift_mat-Tuple{Vector, OMEinsum.AbstractEinsum, Int64, Int64, Matrix}","page":"Home","title":"ParametricDFT.ift_mat","text":"ift_mat(tensors::Vector, code::AbstractEinsum, m::Int, n::Int, pic::Matrix)\n\nApply inverse 2D DFT using the inverse QFT circuit with trained parameters.\n\nArguments\n\ntensors::Vector: Circuit tensors (unitary matrices) from inverse QFT (use qft_code(m, n; inverse=true))\ncode::AbstractEinsum: Optimized einsum code from inverse QFT\nm::Int: Number of qubits for row dimension\nn::Int: Number of qubits for column dimension\npic::Matrix: Input in frequency domain (size 2^m × 2^n)\n\nReturns\n\nTransformed image in spatial domain (size 2^m × 2^n)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.image_size-Tuple{EntangledQFTBasis}","page":"Home","title":"ParametricDFT.image_size","text":"image_size(basis::EntangledQFTBasis)\n\nReturn the supported image dimensions for this basis.\n\nReturns\n\nTuple{Int,Int}: (height, width) = (2^m, 2^n)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.image_size-Tuple{QFTBasis}","page":"Home","title":"ParametricDFT.image_size","text":"image_size(basis::QFTBasis)\n\nReturn the supported image dimensions for this basis.\n\nReturns\n\nTuple{Int,Int}: (height, width) = (2^m, 2^n)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.inverse_transform-Tuple{EntangledQFTBasis, AbstractMatrix}","page":"Home","title":"ParametricDFT.inverse_transform","text":"inverse_transform(basis::EntangledQFTBasis, freq_domain::AbstractMatrix)\n\nApply inverse entangled QFT transform to convert frequency domain back to image.\n\nArguments\n\nbasis::EntangledQFTBasis: The basis to use for transformation\nfreq_domain::AbstractMatrix: Frequency domain data (size 2^m × 2^n)\n\nReturns\n\nReconstructed image (Complex matrix of same size)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.inverse_transform-Tuple{QFTBasis, AbstractMatrix}","page":"Home","title":"ParametricDFT.inverse_transform","text":"inverse_transform(basis::QFTBasis, freq_domain::AbstractMatrix)\n\nApply inverse transform to convert frequency domain back to image.\n\nArguments\n\nbasis::QFTBasis: The basis to use for transformation\nfreq_domain::AbstractMatrix: Frequency domain data (size 2^m × 2^n)\n\nReturns\n\nReconstructed image (Complex matrix of same size)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.load_basis-Tuple{String}","page":"Home","title":"ParametricDFT.load_basis","text":"load_basis(path::String) -> AbstractSparseBasis\n\nLoad a sparse basis from a JSON file.\n\nArguments\n\npath::String: Path to the JSON file\n\nReturns\n\nAbstractSparseBasis: The loaded basis (concrete type depends on file contents)\n\nExample\n\nbasis = load_basis(\"trained_basis.json\")\nfreq = forward_transform(basis, image)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.load_compressed-Tuple{String}","page":"Home","title":"ParametricDFT.load_compressed","text":"load_compressed(path::String) -> CompressedImage\n\nLoad a compressed image from a JSON file.\n\nArguments\n\npath::String: Path to the compressed image file\n\nReturns\n\nCompressedImage: The loaded compressed image\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.loss_function-Tuple{AbstractVector, Int64, Int64, OMEinsum.AbstractEinsum, Matrix, AbstractLoss}","page":"Home","title":"ParametricDFT.loss_function","text":"loss_function(tensors, m::Int, n::Int, optcode::AbstractEinsum, pic::Matrix, loss::AbstractLoss; inverse_code=nothing)\n\nCompute the loss for current circuit parameters.\n\nArguments\n\ntensors::Vector: Circuit parameters (unitary matrices)\nm::Int: Number of qubits for row dimension\nn::Int: Number of qubits for column dimension\noptcode::AbstractEinsum: Optimized einsum code (forward transform)\npic::Matrix: Input signal (size must be 2^m × 2^n)\nloss::AbstractLoss: Loss function type\ninverse_code::AbstractEinsum: Optional inverse einsum code (required for MSELoss)\n\nReturns\n\nLoss value\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.num_entangle_parameters-Tuple{EntangledQFTBasis}","page":"Home","title":"ParametricDFT.num_entangle_parameters","text":"num_entangle_parameters(basis::EntangledQFTBasis)\n\nReturn the number of entanglement phase parameters.\n\nReturns\n\nInt: Number of entanglement gates (= min(m, n))\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.num_parameters-Tuple{EntangledQFTBasis}","page":"Home","title":"ParametricDFT.num_parameters","text":"num_parameters(basis::EntangledQFTBasis)\n\nReturn the total number of learnable parameters in the basis.\n\nFor EntangledQFTBasis:\n\nStandard QFT parameters (Hadamard gates + M gates)\nAdditional n entanglement gate phases (one per qubit pair)\n\nReturns\n\nInt: Total parameter count\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.num_parameters-Tuple{QFTBasis}","page":"Home","title":"ParametricDFT.num_parameters","text":"num_parameters(basis::QFTBasis)\n\nReturn the total number of learnable parameters in the basis.\n\nFor QFT basis:\n\nn Hadamard gates: 4n parameters each (2×2 unitary)\nn(n-1)/2 controlled-phase gates: 4 parameters each (diagonal 2×2)\n\nReturns\n\nInt: Total parameter count\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.point2tensors-Tuple{Any, Any}","page":"Home","title":"ParametricDFT.point2tensors","text":"point2tensors(p, M)\n\nConvert a manifold point back to circuit tensors (unitary matrices).\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.qft_code-Tuple{Int64, Int64}","page":"Home","title":"ParametricDFT.qft_code","text":"qft_code(m::Int, n::Int; inverse=false)\n\nGenerate an optimized tensor network representation of the QFT circuit.\n\nArguments\n\nm::Int: Number of qubits for row indices\nn::Int: Number of qubits for column indices\ninverse::Bool: If true, generate inverse transform code\n\nReturns\n\noptcode::AbstractEinsum: Optimized einsum contraction code\ntensors::Vector: Initial circuit parameters (unitary matrices)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.recover-Tuple{AbstractSparseBasis, CompressedImage}","page":"Home","title":"ParametricDFT.recover","text":"recover(basis::AbstractSparseBasis, compressed::CompressedImage; verify_hash::Bool=true)\n\nRecover an image from its compressed representation.\n\nArguments\n\nbasis::AbstractSparseBasis: The basis used for compression\ncompressed::CompressedImage: The compressed image data\nverify_hash::Bool = true: Whether to verify basis hash matches\n\nReturns\n\nMatrix{Float64}: Reconstructed image (real-valued)\n\nExample\n\nbasis = load_basis(\"trained_basis.json\")\ncompressed = load_compressed(\"photo.cimg\")\nrecovered = recover(basis, compressed)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.save_basis-Tuple{String, AbstractSparseBasis}","page":"Home","title":"ParametricDFT.save_basis","text":"save_basis(path::String, basis::AbstractSparseBasis)\n\nSave a sparse basis to a JSON file.\n\nArguments\n\npath::String: File path to save to (should end in .json)\nbasis::AbstractSparseBasis: The basis to save\n\nExample\n\nbasis = train_basis(QFTBasis, images; m=6, n=6)\nsave_basis(\"trained_basis.json\", basis)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.save_compressed-Tuple{String, CompressedImage}","page":"Home","title":"ParametricDFT.save_compressed","text":"save_compressed(path::String, compressed::CompressedImage)\n\nSave a compressed image to a JSON file.\n\nArguments\n\npath::String: File path to save to\ncompressed::CompressedImage: The compressed image to save\n\nReturns\n\nString: The path where the file was saved\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.tensors2point-Tuple{Any, ManifoldsBase.ProductManifold}","page":"Home","title":"ParametricDFT.tensors2point","text":"tensors2point(tensors, M::ProductManifold)\n\nConvert circuit tensors (unitary matrices) to a point on the product manifold.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.topk_truncate-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer}} where T","page":"Home","title":"ParametricDFT.topk_truncate","text":"topk_truncate(x::AbstractMatrix, k::Integer)\n\nReturn a matrix where frequency-dependent truncation is applied for image compression. Low-frequency components (near center) are kept with higher priority, while high-frequency components (away from center) are kept with lower priority.\n\nThis is more appropriate for image compression than global top-k selection, as it preserves more low-frequency information which contains most of the image structure.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.train_basis-Tuple{Type{EntangledQFTBasis}, Vector{<:AbstractMatrix}}","page":"Home","title":"ParametricDFT.train_basis","text":"train_basis(::Type{EntangledQFTBasis}, dataset::Vector{<:AbstractMatrix}; kwargs...)\n\nTrain an EntangledQFTBasis on a dataset of images using Riemannian gradient descent.\n\nThe EntangledQFTBasis extends the standard QFT by adding entanglement gates Ek between corresponding row and column qubits. Each entanglement gate has a learnable phase parameter phik.\n\nArguments\n\n::Type{EntangledQFTBasis}: The basis type to train\ndataset::Vector{<:AbstractMatrix}: Training images (each must be 2^m × 2^n)\n\nKeyword Arguments\n\nm::Int: Number of qubits for rows (image height = 2^m)\nn::Int: Number of qubits for columns (image width = 2^n)\nentangle_phases::Union{Nothing, Vector{<:Real}}: Initial phases for entanglement gates. If nothing, defaults to zeros.\nloss::AbstractLoss = MSELoss(k): Loss function for training\nepochs::Int = 3: Number of training epochs\nsteps_per_image::Int = 200: Gradient descent steps per image\nvalidation_split::Float64 = 0.2: Fraction of data for validation\nshuffle::Bool = true: Whether to shuffle data each epoch\nearly_stopping_patience::Int = 2: Epochs without improvement before stopping\nverbose::Bool = true: Whether to print training progress\n\nReturns\n\nEntangledQFTBasis: Trained basis with optimized parameters including entanglement phases\n\nExample\n\n# Load images as matrices\nimages = [load_image(path) for path in image_paths]\n\n# Train entangled basis for 64×64 images with 90% compression\nk = round(Int, 64 * 64 * 0.1)  # Keep 10% of coefficients\nbasis = train_basis(EntangledQFTBasis, images; m=6, n=6, loss=MSELoss(k), epochs=5)\n\n# The trained basis will have optimized entanglement phases\nphases = get_entangle_phases(basis)\n\n# Save the trained basis\nsave_basis(\"entangled_basis.json\", basis)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.train_basis-Tuple{Type{QFTBasis}, Vector{<:AbstractMatrix}}","page":"Home","title":"ParametricDFT.train_basis","text":"train_basis(::Type{QFTBasis}, dataset::Vector{<:AbstractMatrix}; kwargs...)\n\nTrain a QFTBasis on a dataset of images using Riemannian gradient descent.\n\nArguments\n\n::Type{QFTBasis}: The basis type to train\ndataset::Vector{<:AbstractMatrix}: Training images (each must be 2^m × 2^n)\n\nKeyword Arguments\n\nm::Int: Number of qubits for rows (image height = 2^m)\nn::Int: Number of qubits for columns (image width = 2^n)\nloss::AbstractLoss = MSELoss(k): Loss function for training\nepochs::Int = 3: Number of training epochs\nsteps_per_image::Int = 200: Gradient descent steps per image\nvalidation_split::Float64 = 0.2: Fraction of data for validation\nshuffle::Bool = true: Whether to shuffle data each epoch\nearly_stopping_patience::Int = 2: Epochs without improvement before stopping\nverbose::Bool = true: Whether to print training progress\n\nReturns\n\nQFTBasis: Trained basis with optimized parameters\n\nExample\n\n# Load images as matrices\nimages = [load_image(path) for path in image_paths]\n\n# Train basis for 64×64 images with 90% compression\nk = round(Int, 64 * 64 * 0.1)  # Keep 10% of coefficients\nbasis = train_basis(QFTBasis, images; m=6, n=6, loss=MSELoss(k), epochs=5)\n\n# Save the trained basis\nsave_basis(\"trained_basis.json\", basis)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.train_basis_from_files","page":"Home","title":"ParametricDFT.train_basis_from_files","text":"train_basis_from_files(::Type{QFTBasis}, image_paths::Vector{String}; \n                      target_size::Int, kwargs...)\n\nTrain a QFTBasis from image files, automatically resizing to power-of-2 dimensions.\n\nArguments\n\n::Type{QFTBasis}: The basis type to train\nimage_paths::Vector{String}: Paths to image files\n\nKeyword Arguments\n\ntarget_size::Int: Target size (must be power of 2, e.g., 64, 128, 256, 512)\nkwargs...: Additional arguments passed to train_basis\n\nReturns\n\nQFTBasis: Trained basis\n\nNote\n\nThis function requires the Images.jl package to be loaded.\n\n\n\n\n\n","category":"function"}]
}
