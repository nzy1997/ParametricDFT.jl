var documenterSearchIndex = {"docs":
[{"location":"#ParametricDFT","page":"Home","title":"ParametricDFT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ParametricDFT.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#ParametricDFT.AbstractLoss","page":"Home","title":"ParametricDFT.AbstractLoss","text":"AbstractLoss\n\nAbstract base type for loss functions. Custom loss functions should inherit from  this type and implement _loss_function(fft_result, input, loss).\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.L1Norm","page":"Home","title":"ParametricDFT.L1Norm","text":"L1Norm <: AbstractLoss\n\nL1 norm loss: minimizes sum of absolute values in the transformed domain. This encourages sparsity in the frequency representation.\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.fft_with_training-Tuple{Int64, Vector, AbstractLoss}","page":"Home","title":"ParametricDFT.fft_with_training","text":"fft_with_training(n::Int, pic::Vector, loss::AbstractLoss; steps::Int=1000)\n\nTrain a parametric quantum DFT circuit using Riemannian gradient descent.\n\nArguments\n\nn::Int: Number of qubits (input length must be 2^n)\npic::Vector: Input signal\nloss::AbstractLoss: Loss function (e.g., L1Norm())\nsteps::Int=1000: Maximum optimization iterations\n\nReturns\n\nOptimized parameters on the manifold (use point2tensors to convert to tensors)\n\nExample\n\ntheta = fft_with_training(8, rand(256), L1Norm(); steps=200)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.ft_mat-Tuple{Vector, OMEinsum.AbstractEinsum, Int64}","page":"Home","title":"ParametricDFT.ft_mat","text":"ft_mat(theta::Vector, code::AbstractEinsum, n::Int)\n\nConstruct DFT matrix from circuit parameters by contracting the tensor network.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.generate_manifold-Tuple{Int64}","page":"Home","title":"ParametricDFT.generate_manifold","text":"generate_manifold(n::Int)\n\nGenerate product manifold for n-qubit QFT parameters. Returns a product of U(2) manifolds for Hadamard gates and U(1)^4 for controlled gates.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.ift_mat-Tuple{Vector, OMEinsum.AbstractEinsum, Int64}","page":"Home","title":"ParametricDFT.ift_mat","text":"ift_mat(tensors::Vector, code::AbstractEinsum, n::Int)\n\nConstruct inverse DFT matrix from circuit parameters.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.loss_function-Tuple{Any, Int64, OMEinsum.AbstractEinsum, Vector, AbstractLoss}","page":"Home","title":"ParametricDFT.loss_function","text":"loss_function(tensors, n::Int, optcode::AbstractEinsum, pic::Vector, loss::AbstractLoss)\n\nCompute the loss for current circuit parameters.\n\nArguments\n\ntensors::Vector: Circuit parameters (unitary matrices)\nn::Int: Number of qubits\noptcode::AbstractEinsum: Optimized einsum code\npic::Vector: Input signal (length must be 2^n)\nloss::AbstractLoss: Loss function type\n\nReturns\n\nLoss value\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.point2tensors-Tuple{Any, Int64}","page":"Home","title":"ParametricDFT.point2tensors","text":"point2tensors(p, n::Int)\n\nConvert a manifold point back to circuit tensors (unitary matrices).\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.qft_code-Tuple{Int64}","page":"Home","title":"ParametricDFT.qft_code","text":"qft_code(qubit_num::Int)\n\nGenerate an optimized tensor network representation of the QFT circuit.\n\nArguments\n\nqubit_num::Int: Number of qubits\n\nReturns\n\noptcode::AbstractEinsum: Optimized einsum contraction code\ntensors::Vector: Initial circuit parameters (unitary matrices)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.tensors2point-Tuple{Any, Int64}","page":"Home","title":"ParametricDFT.tensors2point","text":"tensors2point(tensors, n::Int)\n\nConvert circuit tensors (unitary matrices) to a point on the product manifold.\n\n\n\n\n\n","category":"method"}]
}
