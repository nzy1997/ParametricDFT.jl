var documenterSearchIndex = {"docs":
[{"location":"#ParametricDFT","page":"Home","title":"ParametricDFT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ParametricDFT.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#ParametricDFT.AbstractLoss","page":"Home","title":"ParametricDFT.AbstractLoss","text":"AbstractLoss\n\nAbstract base type for loss functions. Custom loss functions should inherit from  this type and implement _loss_function(fft_result, input, loss).\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.L1Norm","page":"Home","title":"ParametricDFT.L1Norm","text":"L1Norm <: AbstractLoss\n\nL1 norm loss: minimizes sum of absolute values in the transformed domain. This encourages sparsity in the frequency representation.\n\n\n\n\n\n","category":"type"},{"location":"#ParametricDFT.fft_with_training-Tuple{Int64, Int64, Matrix, AbstractLoss}","page":"Home","title":"ParametricDFT.fft_with_training","text":"fft_with_training(m::Int, n::Int, pic::Matrix, loss::AbstractLoss; steps::Int=1000, use_cuda::Bool=false)\n\nTrain a parametric 2D quantum DFT circuit using Riemannian gradient descent.\n\nArguments\n\nm::Int: Number of qubits for row dimension (image height = 2^m)\nn::Int: Number of qubits for column dimension (image width = 2^n)\npic::Matrix: Input signal (size must be 2^m × 2^n)\nloss::AbstractLoss: Loss function (e.g., L1Norm())\nsteps::Int=1000: Maximum optimization iterations\nuse_cuda::Bool=false: Whether to use CUDA acceleration (not yet implemented)\n\nReturns\n\nOptimized parameters on the manifold (use point2tensors to convert to tensors)\n\nExample\n\nm, n = 6, 6  # For 64×64 image\npic = rand(ComplexF64, 2^m, 2^n)\ntheta = fft_with_training(m, n, pic, L1Norm(); steps=200)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.ft_mat-Tuple{Vector, OMEinsum.AbstractEinsum, Int64, Int64, Matrix}","page":"Home","title":"ParametricDFT.ft_mat","text":"ft_mat(tensors::Vector, code::AbstractEinsum, m::Int, n::Int, pic::Matrix)\n\nApply 2D DFT to an image using the trained circuit parameters.\n\nArguments\n\ntensors::Vector: Circuit tensors (unitary matrices)\ncode::AbstractEinsum: Optimized einsum code\nm::Int: Number of qubits for row dimension\nn::Int: Number of qubits for column dimension\npic::Matrix: Input image (size 2^m × 2^n)\n\nReturns\n\nTransformed image in frequency domain (size 2^m × 2^n)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.generate_manifold-Tuple{Any}","page":"Home","title":"ParametricDFT.generate_manifold","text":"generate_manifold(tensors)\n\nGenerate product manifold for m+n-qubit QFT parameters. Returns a product of U(2) manifolds for Hadamard gates and U(1)^4 for controlled gates.\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.ift_mat-Tuple{Vector, OMEinsum.AbstractEinsum, Int64, Int64, Matrix}","page":"Home","title":"ParametricDFT.ift_mat","text":"ift_mat(tensors::Vector, code::AbstractEinsum, m::Int, n::Int, pic::Matrix)\n\nApply inverse 2D DFT using the inverse QFT circuit with trained parameters.\n\nArguments\n\ntensors::Vector: Circuit tensors (unitary matrices) from inverse QFT (use qft_code(m, n; inverse=true))\ncode::AbstractEinsum: Optimized einsum code from inverse QFT\nm::Int: Number of qubits for row dimension\nn::Int: Number of qubits for column dimension\npic::Matrix: Input in frequency domain (size 2^m × 2^n)\n\nReturns\n\nTransformed image in spatial domain (size 2^m × 2^n)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.loss_function-Tuple{Any, Int64, Int64, OMEinsum.AbstractEinsum, Matrix, AbstractLoss}","page":"Home","title":"ParametricDFT.loss_function","text":"loss_function(tensors, n::Int, optcode::AbstractEinsum, pic::Vector, loss::AbstractLoss)\n\nCompute the loss for current circuit parameters.\n\nArguments\n\ntensors::Vector: Circuit parameters (unitary matrices)\nn::Int: Number of qubits\noptcode::AbstractEinsum: Optimized einsum code\npic::Matrix: Input signal (size must be 2^m × 2^n)\nloss::AbstractLoss: Loss function type\n\nReturns\n\nLoss value\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.point2tensors-Tuple{Any, Any}","page":"Home","title":"ParametricDFT.point2tensors","text":"point2tensors(p, M)\n\nConvert a manifold point back to circuit tensors (unitary matrices).\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.qft_code-Tuple{Int64, Int64}","page":"Home","title":"ParametricDFT.qft_code","text":"qft_code(m::Int, n::Int)\n\nGenerate an optimized tensor network representation of the QFT circuit.\n\nArguments\n\nm::Int: Number of qubits for row indices\nn::Int: Number of qubits for column indices\n\nReturns\n\noptcode::AbstractEinsum: Optimized einsum contraction code\ntensors::Vector: Initial circuit parameters (unitary matrices)\n\n\n\n\n\n","category":"method"},{"location":"#ParametricDFT.tensors2point-Tuple{Any, ManifoldsBase.ProductManifold}","page":"Home","title":"ParametricDFT.tensors2point","text":"tensors2point(tensors, M::ProductManifold)\n\nConvert circuit tensors (unitary matrices) to a point on the product manifold.\n\n\n\n\n\n","category":"method"}]
}
