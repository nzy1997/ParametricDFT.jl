<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ParametricDFT.jl</title><meta name="title" content="Home · ParametricDFT.jl"/><meta property="og:title" content="Home · ParametricDFT.jl"/><meta property="twitter:title" content="Home · ParametricDFT.jl"/><meta name="description" content="Documentation for ParametricDFT.jl."/><meta property="og:description" content="Documentation for ParametricDFT.jl."/><meta property="twitter:description" content="Documentation for ParametricDFT.jl."/><meta property="og:url" content="https://nzy1997.github.io/ParametricDFT.jl/"/><meta property="twitter:url" content="https://nzy1997.github.io/ParametricDFT.jl/"/><link rel="canonical" href="https://nzy1997.github.io/ParametricDFT.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ParametricDFT.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/nzy1997/ParametricDFT.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/nzy1997/ParametricDFT.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ParametricDFT"><a class="docs-heading-anchor" href="#ParametricDFT">ParametricDFT</a><a id="ParametricDFT-1"></a><a class="docs-heading-anchor-permalink" href="#ParametricDFT" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/nzy1997/ParametricDFT.jl">ParametricDFT</a>.</p><ul><li><a href="#ParametricDFT.AbstractLoss"><code>ParametricDFT.AbstractLoss</code></a></li><li><a href="#ParametricDFT.AbstractSparseBasis"><code>ParametricDFT.AbstractSparseBasis</code></a></li><li><a href="#ParametricDFT.BasisJSON"><code>ParametricDFT.BasisJSON</code></a></li><li><a href="#ParametricDFT.CompressedImage"><code>ParametricDFT.CompressedImage</code></a></li><li><a href="#ParametricDFT.CompressedImageJSON"><code>ParametricDFT.CompressedImageJSON</code></a></li><li><a href="#ParametricDFT.EntangledBasisJSON"><code>ParametricDFT.EntangledBasisJSON</code></a></li><li><a href="#ParametricDFT.EntangledQFTBasis"><code>ParametricDFT.EntangledQFTBasis</code></a></li><li><a href="#ParametricDFT.EntangledQFTBasis-Tuple{Int64, Int64}"><code>ParametricDFT.EntangledQFTBasis</code></a></li><li><a href="#ParametricDFT.EntangledQFTBasis-Tuple{Int64, Int64, Vector, Int64}"><code>ParametricDFT.EntangledQFTBasis</code></a></li><li><a href="#ParametricDFT.L1Norm"><code>ParametricDFT.L1Norm</code></a></li><li><a href="#ParametricDFT.L2Norm"><code>ParametricDFT.L2Norm</code></a></li><li><a href="#ParametricDFT.MSELoss"><code>ParametricDFT.MSELoss</code></a></li><li><a href="#ParametricDFT.QFTBasis-Tuple{Int64, Int64}"><code>ParametricDFT.QFTBasis</code></a></li><li><a href="#ParametricDFT.QFTBasis"><code>ParametricDFT.QFTBasis</code></a></li><li><a href="#ParametricDFT.QFTBasis-Tuple{Int64, Int64, Vector}"><code>ParametricDFT.QFTBasis</code></a></li><li><a href="#Base.:==-Tuple{QFTBasis, QFTBasis}"><code>Base.:==</code></a></li><li><a href="#Base.:==-Tuple{EntangledQFTBasis, EntangledQFTBasis}"><code>Base.:==</code></a></li><li><a href="#Base.show-Tuple{IO, CompressedImage}"><code>Base.show</code></a></li><li><a href="#Base.show-Tuple{IO, EntangledQFTBasis}"><code>Base.show</code></a></li><li><a href="#Base.show-Tuple{IO, QFTBasis}"><code>Base.show</code></a></li><li><a href="#ParametricDFT._basis_to_json-Tuple{EntangledQFTBasis}"><code>ParametricDFT._basis_to_json</code></a></li><li><a href="#ParametricDFT._basis_to_json-Tuple{QFTBasis}"><code>ParametricDFT._basis_to_json</code></a></li><li><a href="#ParametricDFT._compute_basis_loss-Tuple{AbstractMatrix, Vector, OMEinsum.AbstractEinsum, OMEinsum.AbstractEinsum, Int64, Int64, AbstractLoss}"><code>ParametricDFT._compute_basis_loss</code></a></li><li><a href="#ParametricDFT._compute_validation_loss-Tuple{Vector{&lt;:AbstractMatrix}, Vector, OMEinsum.AbstractEinsum, OMEinsum.AbstractEinsum, Int64, Int64, AbstractLoss}"><code>ParametricDFT._compute_validation_loss</code></a></li><li><a href="#ParametricDFT._json_to_basis-Tuple{ParametricDFT.BasisJSON}"><code>ParametricDFT._json_to_basis</code></a></li><li><a href="#ParametricDFT._json_to_entangled_basis-Tuple{ParametricDFT.EntangledBasisJSON}"><code>ParametricDFT._json_to_entangled_basis</code></a></li><li><a href="#ParametricDFT._reconstruct_frequency_domain-Tuple{CompressedImage, Tuple{Int64, Int64}}"><code>ParametricDFT._reconstruct_frequency_domain</code></a></li><li><a href="#ParametricDFT._select_top_coefficients-Tuple{AbstractMatrix, Int64}"><code>ParametricDFT._select_top_coefficients</code></a></li><li><a href="#ParametricDFT._train_on_single_image-Tuple{AbstractMatrix, Any, ManifoldsBase.ProductManifold, OMEinsum.AbstractEinsum, OMEinsum.AbstractEinsum, Int64, Int64, AbstractLoss, Int64}"><code>ParametricDFT._train_on_single_image</code></a></li><li><a href="#ParametricDFT.basis_hash-Tuple{QFTBasis}"><code>ParametricDFT.basis_hash</code></a></li><li><a href="#ParametricDFT.basis_hash-Tuple{EntangledQFTBasis}"><code>ParametricDFT.basis_hash</code></a></li><li><a href="#ParametricDFT.basis_to_dict-Tuple{EntangledQFTBasis}"><code>ParametricDFT.basis_to_dict</code></a></li><li><a href="#ParametricDFT.basis_to_dict-Tuple{QFTBasis}"><code>ParametricDFT.basis_to_dict</code></a></li><li><a href="#ParametricDFT.compress-Tuple{AbstractSparseBasis, AbstractMatrix}"><code>ParametricDFT.compress</code></a></li><li><a href="#ParametricDFT.compress_with_k-Tuple{AbstractSparseBasis, AbstractMatrix}"><code>ParametricDFT.compress_with_k</code></a></li><li><a href="#ParametricDFT.compression_stats-Tuple{CompressedImage}"><code>ParametricDFT.compression_stats</code></a></li><li><a href="#ParametricDFT.dict_to_basis-Tuple{Dict}"><code>ParametricDFT.dict_to_basis</code></a></li><li><a href="#ParametricDFT.entangled_qft_code-Tuple{Int64, Int64}"><code>ParametricDFT.entangled_qft_code</code></a></li><li><a href="#ParametricDFT.entanglement_gate-Tuple{Real}"><code>ParametricDFT.entanglement_gate</code></a></li><li><a href="#ParametricDFT.extract_entangle_phases-Tuple{Any, Vector{Int64}}"><code>ParametricDFT.extract_entangle_phases</code></a></li><li><a href="#ParametricDFT.fft_with_training-Tuple{Int64, Int64, Matrix, AbstractLoss}"><code>ParametricDFT.fft_with_training</code></a></li><li><a href="#ParametricDFT.forward_transform-Tuple{EntangledQFTBasis, AbstractMatrix}"><code>ParametricDFT.forward_transform</code></a></li><li><a href="#ParametricDFT.forward_transform-Tuple{QFTBasis, AbstractMatrix}"><code>ParametricDFT.forward_transform</code></a></li><li><a href="#ParametricDFT.ft_mat-Tuple{Vector, OMEinsum.AbstractEinsum, Int64, Int64, Matrix}"><code>ParametricDFT.ft_mat</code></a></li><li><a href="#ParametricDFT.generate_manifold-Tuple{Any}"><code>ParametricDFT.generate_manifold</code></a></li><li><a href="#ParametricDFT.get_entangle_phases-Tuple{EntangledQFTBasis}"><code>ParametricDFT.get_entangle_phases</code></a></li><li><a href="#ParametricDFT.get_entangle_tensor_indices-Tuple{Any, Int64}"><code>ParametricDFT.get_entangle_tensor_indices</code></a></li><li><a href="#ParametricDFT.get_manifold-Tuple{EntangledQFTBasis}"><code>ParametricDFT.get_manifold</code></a></li><li><a href="#ParametricDFT.get_manifold-Tuple{QFTBasis}"><code>ParametricDFT.get_manifold</code></a></li><li><a href="#ParametricDFT.ift_mat-Tuple{Vector, OMEinsum.AbstractEinsum, Int64, Int64, Matrix}"><code>ParametricDFT.ift_mat</code></a></li><li><a href="#ParametricDFT.image_size-Tuple{EntangledQFTBasis}"><code>ParametricDFT.image_size</code></a></li><li><a href="#ParametricDFT.image_size-Tuple{QFTBasis}"><code>ParametricDFT.image_size</code></a></li><li><a href="#ParametricDFT.inverse_transform-Tuple{QFTBasis, AbstractMatrix}"><code>ParametricDFT.inverse_transform</code></a></li><li><a href="#ParametricDFT.inverse_transform-Tuple{EntangledQFTBasis, AbstractMatrix}"><code>ParametricDFT.inverse_transform</code></a></li><li><a href="#ParametricDFT.load_basis-Tuple{String}"><code>ParametricDFT.load_basis</code></a></li><li><a href="#ParametricDFT.load_compressed-Tuple{String}"><code>ParametricDFT.load_compressed</code></a></li><li><a href="#ParametricDFT.loss_function-Tuple{AbstractVector, Int64, Int64, OMEinsum.AbstractEinsum, Matrix, AbstractLoss}"><code>ParametricDFT.loss_function</code></a></li><li><a href="#ParametricDFT.num_entangle_parameters-Tuple{EntangledQFTBasis}"><code>ParametricDFT.num_entangle_parameters</code></a></li><li><a href="#ParametricDFT.num_parameters-Tuple{EntangledQFTBasis}"><code>ParametricDFT.num_parameters</code></a></li><li><a href="#ParametricDFT.num_parameters-Tuple{QFTBasis}"><code>ParametricDFT.num_parameters</code></a></li><li><a href="#ParametricDFT.point2tensors-Tuple{Any, Any}"><code>ParametricDFT.point2tensors</code></a></li><li><a href="#ParametricDFT.qft_code-Tuple{Int64, Int64}"><code>ParametricDFT.qft_code</code></a></li><li><a href="#ParametricDFT.recover-Tuple{AbstractSparseBasis, CompressedImage}"><code>ParametricDFT.recover</code></a></li><li><a href="#ParametricDFT.save_basis-Tuple{String, AbstractSparseBasis}"><code>ParametricDFT.save_basis</code></a></li><li><a href="#ParametricDFT.save_compressed-Tuple{String, CompressedImage}"><code>ParametricDFT.save_compressed</code></a></li><li><a href="#ParametricDFT.tensors2point-Tuple{Any, ManifoldsBase.ProductManifold}"><code>ParametricDFT.tensors2point</code></a></li><li><a href="#ParametricDFT.topk_truncate-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer}} where T"><code>ParametricDFT.topk_truncate</code></a></li><li><a href="#ParametricDFT.train_basis-Tuple{Type{EntangledQFTBasis}, Vector{&lt;:AbstractMatrix}}"><code>ParametricDFT.train_basis</code></a></li><li><a href="#ParametricDFT.train_basis-Tuple{Type{QFTBasis}, Vector{&lt;:AbstractMatrix}}"><code>ParametricDFT.train_basis</code></a></li><li><a href="#ParametricDFT.train_basis_from_files"><code>ParametricDFT.train_basis_from_files</code></a></li></ul><article><details class="docstring" open="true"><summary id="ParametricDFT.AbstractLoss"><a class="docstring-binding" href="#ParametricDFT.AbstractLoss"><code>ParametricDFT.AbstractLoss</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractLoss</code></pre><p>Abstract base type for loss functions. Custom loss functions should inherit from  this type and implement <code>_loss_function(fft_result, input, loss)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/loss.jl#L6-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.AbstractSparseBasis"><a class="docstring-binding" href="#ParametricDFT.AbstractSparseBasis"><code>ParametricDFT.AbstractSparseBasis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractSparseBasis</code></pre><p>Abstract base type for sparse basis representations. All concrete basis types should inherit from this and implement the required interface:</p><p>Required methods:</p><ul><li><code>forward_transform(basis, image)</code> - transform image to frequency domain</li><li><code>inverse_transform(basis, freq_domain)</code> - inverse transform</li><li><code>image_size(basis)</code> - return supported image dimensions</li><li><code>num_parameters(basis)</code> - return total parameter count</li><li><code>basis_hash(basis)</code> - return unique hash for basis identification</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L7-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.BasisJSON"><a class="docstring-binding" href="#ParametricDFT.BasisJSON"><code>ParametricDFT.BasisJSON</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BasisJSON</code></pre><p>Internal struct for JSON serialization of QFTBasis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/serialization.jl#L10-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.CompressedImage"><a class="docstring-binding" href="#ParametricDFT.CompressedImage"><code>ParametricDFT.CompressedImage</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CompressedImage</code></pre><p>Sparse representation of an image in the frequency domain.</p><p><strong>Fields</strong></p><ul><li><code>indices::Vector{Int}</code>: Linear indices of non-zero coefficients</li><li><code>values_real::Vector{Float64}</code>: Real parts of coefficient values</li><li><code>values_imag::Vector{Float64}</code>: Imaginary parts of coefficient values</li><li><code>original_size::Tuple{Int,Int}</code>: Original image dimensions (height, width)</li><li><code>basis_hash::String</code>: Hash of the basis used for compression (for verification)</li></ul><p><strong>Note</strong></p><p>The compressed representation stores only the non-zero coefficients after truncation, achieving compression by discarding small coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/compression.jl#L11-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.CompressedImageJSON"><a class="docstring-binding" href="#ParametricDFT.CompressedImageJSON"><code>ParametricDFT.CompressedImageJSON</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CompressedImageJSON</code></pre><p>Internal struct for JSON serialization of CompressedImage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/compression.jl#L237-L241">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.EntangledBasisJSON"><a class="docstring-binding" href="#ParametricDFT.EntangledBasisJSON"><code>ParametricDFT.EntangledBasisJSON</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EntangledBasisJSON</code></pre><p>Internal struct for JSON serialization of EntangledQFTBasis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/serialization.jl#L24-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.EntangledQFTBasis"><a class="docstring-binding" href="#ParametricDFT.EntangledQFTBasis"><code>ParametricDFT.EntangledQFTBasis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EntangledQFTBasis &lt;: AbstractSparseBasis</code></pre><p>Entangled Quantum Fourier Transform basis with XY correlation.</p><p>This basis extends the standard QFT by adding entanglement gates E_k between corresponding row and column qubits. Each entanglement gate has the same form as the M gate in QFT:</p><pre><code class="language-julia hljs">E_k = diag(1, 1, 1, e^(i*phi_k))</code></pre><p>acting on qubits (x<em>{n-k}, y</em>{n-k}), where phi_k is a learnable phase parameter.</p><p><strong>Fields</strong></p><ul><li><code>m::Int</code>: Number of qubits for row dimension (image height = 2^m)</li><li><code>n::Int</code>: Number of qubits for column dimension (image width = 2^n)</li><li><code>tensors::Vector</code>: Circuit parameters (unitary matrices + entanglement gates)</li><li><code>optcode::AbstractEinsum</code>: Optimized einsum code for forward transform</li><li><code>inverse_code::AbstractEinsum</code>: Optimized einsum code for inverse transform</li><li><code>n_entangle::Int</code>: Number of entanglement gates (= min(m, n))</li><li><code>entangle_phases::Vector{Float64}</code>: Phase parameters for entanglement gates</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create default entangled QFT basis for 64×64 images
basis = EntangledQFTBasis(6, 6)

# Create with custom initial entanglement phases
phases = rand(6) * 2π
basis = EntangledQFTBasis(6, 6; entangle_phases=phases)

# Transform an image
freq = forward_transform(basis, image)

# Inverse transform
reconstructed = inverse_transform(basis, freq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L240-L277">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.EntangledQFTBasis-Tuple{Int64, Int64, Vector, Int64}"><a class="docstring-binding" href="#ParametricDFT.EntangledQFTBasis-Tuple{Int64, Int64, Vector, Int64}"><code>ParametricDFT.EntangledQFTBasis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">EntangledQFTBasis(m::Int, n::Int, tensors::Vector, n_entangle::Int)</code></pre><p>Construct an EntangledQFTBasis with custom trained tensors.</p><p><strong>Arguments</strong></p><ul><li><code>m::Int</code>: Number of qubits for rows</li><li><code>n::Int</code>: Number of qubits for columns</li><li><code>tensors::Vector</code>: Pre-trained circuit parameters</li><li><code>n_entangle::Int</code>: Number of entanglement gates</li></ul><p><strong>Returns</strong></p><ul><li><code>EntangledQFTBasis</code>: Basis with custom parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L314-L327">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.EntangledQFTBasis-Tuple{Int64, Int64}"><a class="docstring-binding" href="#ParametricDFT.EntangledQFTBasis-Tuple{Int64, Int64}"><code>ParametricDFT.EntangledQFTBasis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">EntangledQFTBasis(m::Int, n::Int; entangle_phases=nothing)</code></pre><p>Construct an EntangledQFTBasis with default or custom entanglement phases.</p><p><strong>Arguments</strong></p><ul><li><code>m::Int</code>: Number of qubits for rows (image height = 2^m)</li><li><code>n::Int</code>: Number of qubits for columns (image width = 2^n)</li><li><code>entangle_phases::Union{Nothing, Vector{&lt;:Real}}</code>: Initial phases for entanglement gates. If nothing, defaults to zeros (equivalent to standard QFT initially).</li></ul><p><strong>Returns</strong></p><ul><li><code>EntangledQFTBasis</code>: Basis with entangled QFT circuit parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L288-L301">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.L1Norm"><a class="docstring-binding" href="#ParametricDFT.L1Norm"><code>ParametricDFT.L1Norm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">L1Norm &lt;: AbstractLoss</code></pre><p>L1 norm loss: minimizes sum of absolute values in the transformed domain. This encourages sparsity in the frequency representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/loss.jl#L14-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.L2Norm"><a class="docstring-binding" href="#ParametricDFT.L2Norm"><code>ParametricDFT.L2Norm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">L2Norm &lt;: AbstractLoss</code></pre><p>L2 norm loss: minimizes sum of squared magnitudes in the transformed domain. This encourages energy concentration (squared magnitude) with smoother gradients compared to L1 norm, and less aggressive sparsity promotion than L1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/loss.jl#L22-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.MSELoss"><a class="docstring-binding" href="#ParametricDFT.MSELoss"><code>ParametricDFT.MSELoss</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MSELoss &lt;: AbstractLoss</code></pre><p>Mean Squared Error loss with truncation: minimizes reconstruction error after forward transform, truncation (keeping top k elements), and inverse transform.</p><p><strong>Fields</strong></p><ul><li><code>k::Int</code>: Number of top elements to keep after truncation (by magnitude)</li></ul><p><strong>Equation</strong></p><p>L(θ) = Σᵢ ||xᵢ - T(θ)⁻¹(truncate(T(θ)(xᵢ), k))||²₂</p><p>This loss encourages the circuit to learn a representation where the top k frequency components capture most of the signal information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/loss.jl#L31-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.QFTBasis"><a class="docstring-binding" href="#ParametricDFT.QFTBasis"><code>ParametricDFT.QFTBasis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">QFTBasis &lt;: AbstractSparseBasis</code></pre><p>Quantum Fourier Transform basis using tensor network representation.</p><p><strong>Fields</strong></p><ul><li><code>m::Int</code>: Number of qubits for row dimension (image height = 2^m)</li><li><code>n::Int</code>: Number of qubits for column dimension (image width = 2^n)</li><li><code>tensors::Vector</code>: Circuit parameters (unitary matrices)</li><li><code>optcode::AbstractEinsum</code>: Optimized einsum code for forward transform</li><li><code>inverse_code::AbstractEinsum</code>: Optimized einsum code for inverse transform</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create default QFT basis for 64×64 images
basis = QFTBasis(6, 6)

# Transform an image
freq = forward_transform(basis, image)

# Inverse transform
reconstructed = inverse_transform(basis, freq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L26-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.QFTBasis-Tuple{Int64, Int64, Vector}"><a class="docstring-binding" href="#ParametricDFT.QFTBasis-Tuple{Int64, Int64, Vector}"><code>ParametricDFT.QFTBasis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">QFTBasis(m::Int, n::Int, tensors::Vector)</code></pre><p>Construct a QFTBasis with custom trained tensors.</p><p><strong>Arguments</strong></p><ul><li><code>m::Int</code>: Number of qubits for rows</li><li><code>n::Int</code>: Number of qubits for columns</li><li><code>tensors::Vector</code>: Pre-trained circuit parameters</li></ul><p><strong>Returns</strong></p><ul><li><code>QFTBasis</code>: Basis with custom parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L76-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.QFTBasis-Tuple{Int64, Int64}"><a class="docstring-binding" href="#ParametricDFT.QFTBasis-Tuple{Int64, Int64}"><code>ParametricDFT.QFTBasis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">QFTBasis(m::Int, n::Int)</code></pre><p>Construct a QFTBasis with default QFT circuit parameters.</p><p><strong>Arguments</strong></p><ul><li><code>m::Int</code>: Number of qubits for rows (image height = 2^m)</li><li><code>n::Int</code>: Number of qubits for columns (image width = 2^n)</li></ul><p><strong>Returns</strong></p><ul><li><code>QFTBasis</code>: Basis with standard QFT circuit parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L58-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Tuple{EntangledQFTBasis, EntangledQFTBasis}"><a class="docstring-binding" href="#Base.:==-Tuple{EntangledQFTBasis, EntangledQFTBasis}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(==)(a::EntangledQFTBasis, b::EntangledQFTBasis)</code></pre><p>Check equality of two EntangledQFTBasis objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L492-L496">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Tuple{QFTBasis, QFTBasis}"><a class="docstring-binding" href="#Base.:==-Tuple{QFTBasis, QFTBasis}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(==)(a::QFTBasis, b::QFTBasis)</code></pre><p>Check equality of two QFTBasis objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L227-L231">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.show-Tuple{IO, CompressedImage}"><a class="docstring-binding" href="#Base.show-Tuple{IO, CompressedImage}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.show(io::IO, compressed::CompressedImage)</code></pre><p>Pretty print the CompressedImage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/compression.jl#L358-L362">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.show-Tuple{IO, EntangledQFTBasis}"><a class="docstring-binding" href="#Base.show-Tuple{IO, EntangledQFTBasis}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.show(io::IO, basis::EntangledQFTBasis)</code></pre><p>Pretty print the EntangledQFTBasis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L480-L484">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.show-Tuple{IO, QFTBasis}"><a class="docstring-binding" href="#Base.show-Tuple{IO, QFTBasis}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.show(io::IO, basis::QFTBasis)</code></pre><p>Pretty print the QFTBasis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L216-L220">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT._basis_to_json-Tuple{EntangledQFTBasis}"><a class="docstring-binding" href="#ParametricDFT._basis_to_json-Tuple{EntangledQFTBasis}"><code>ParametricDFT._basis_to_json</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_basis_to_json(basis::EntangledQFTBasis)</code></pre><p>Convert an EntangledQFTBasis to JSON-serializable format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/serialization.jl#L99-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT._basis_to_json-Tuple{QFTBasis}"><a class="docstring-binding" href="#ParametricDFT._basis_to_json-Tuple{QFTBasis}"><code>ParametricDFT._basis_to_json</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_basis_to_json(basis::QFTBasis)</code></pre><p>Convert a QFTBasis to JSON-serializable format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/serialization.jl#L71-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT._compute_basis_loss-Tuple{AbstractMatrix, Vector, OMEinsum.AbstractEinsum, OMEinsum.AbstractEinsum, Int64, Int64, AbstractLoss}"><a class="docstring-binding" href="#ParametricDFT._compute_basis_loss-Tuple{AbstractMatrix, Vector, OMEinsum.AbstractEinsum, OMEinsum.AbstractEinsum, Int64, Int64, AbstractLoss}"><code>ParametricDFT._compute_basis_loss</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_compute_basis_loss(img_matrix, tensors, optcode, inverse_code, m, n, loss)</code></pre><p>Compute loss for a single image given current tensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/training.jl#L426-L430">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT._compute_validation_loss-Tuple{Vector{&lt;:AbstractMatrix}, Vector, OMEinsum.AbstractEinsum, OMEinsum.AbstractEinsum, Int64, Int64, AbstractLoss}"><a class="docstring-binding" href="#ParametricDFT._compute_validation_loss-Tuple{Vector{&lt;:AbstractMatrix}, Vector, OMEinsum.AbstractEinsum, OMEinsum.AbstractEinsum, Int64, Int64, AbstractLoss}"><code>ParametricDFT._compute_validation_loss</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_compute_validation_loss(validation_data, tensors, optcode, inverse_code, m, n, loss)</code></pre><p>Compute average loss over validation set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/training.jl#L443-L447">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT._json_to_basis-Tuple{ParametricDFT.BasisJSON}"><a class="docstring-binding" href="#ParametricDFT._json_to_basis-Tuple{ParametricDFT.BasisJSON}"><code>ParametricDFT._json_to_basis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_json_to_basis(json_data::BasisJSON)</code></pre><p>Convert JSON data back to a QFTBasis object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/serialization.jl#L165-L169">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT._json_to_entangled_basis-Tuple{ParametricDFT.EntangledBasisJSON}"><a class="docstring-binding" href="#ParametricDFT._json_to_entangled_basis-Tuple{ParametricDFT.EntangledBasisJSON}"><code>ParametricDFT._json_to_entangled_basis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_json_to_entangled_basis(json_data::EntangledBasisJSON)</code></pre><p>Convert JSON data back to an EntangledQFTBasis object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/serialization.jl#L210-L214">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT._reconstruct_frequency_domain-Tuple{CompressedImage, Tuple{Int64, Int64}}"><a class="docstring-binding" href="#ParametricDFT._reconstruct_frequency_domain-Tuple{CompressedImage, Tuple{Int64, Int64}}"><code>ParametricDFT._reconstruct_frequency_domain</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_reconstruct_frequency_domain(compressed::CompressedImage, size::Tuple{Int,Int})</code></pre><p>Reconstruct full frequency domain matrix from sparse representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/compression.jl#L218-L222">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT._select_top_coefficients-Tuple{AbstractMatrix, Int64}"><a class="docstring-binding" href="#ParametricDFT._select_top_coefficients-Tuple{AbstractMatrix, Int64}"><code>ParametricDFT._select_top_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_select_top_coefficients(freq_domain::AbstractMatrix, k::Int)</code></pre><p>Select top k coefficients using frequency-weighted magnitude scoring.</p><p>Low-frequency components (near center) are prioritized as they typically contain more important structural information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/compression.jl#L132-L139">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT._train_on_single_image-Tuple{AbstractMatrix, Any, ManifoldsBase.ProductManifold, OMEinsum.AbstractEinsum, OMEinsum.AbstractEinsum, Int64, Int64, AbstractLoss, Int64}"><a class="docstring-binding" href="#ParametricDFT._train_on_single_image-Tuple{AbstractMatrix, Any, ManifoldsBase.ProductManifold, OMEinsum.AbstractEinsum, OMEinsum.AbstractEinsum, Int64, Int64, AbstractLoss, Int64}"><code>ParametricDFT._train_on_single_image</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_train_on_single_image(img_matrix, theta, M, optcode, inverse_code, m, n, loss, steps)</code></pre><p>Train on a single image using gradient descent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/training.jl#L388-L392">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.basis_hash-Tuple{EntangledQFTBasis}"><a class="docstring-binding" href="#ParametricDFT.basis_hash-Tuple{EntangledQFTBasis}"><code>ParametricDFT.basis_hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">basis_hash(basis::EntangledQFTBasis)</code></pre><p>Compute a unique hash identifying this basis configuration and parameters.</p><p><strong>Returns</strong></p><ul><li><code>String</code>: SHA-256 hash of the basis parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L445-L452">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.basis_hash-Tuple{QFTBasis}"><a class="docstring-binding" href="#ParametricDFT.basis_hash-Tuple{QFTBasis}"><code>ParametricDFT.basis_hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">basis_hash(basis::QFTBasis)</code></pre><p>Compute a unique hash identifying this basis configuration and parameters.</p><p><strong>Returns</strong></p><ul><li><code>String</code>: SHA-256 hash of the basis parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L180-L187">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.basis_to_dict-Tuple{EntangledQFTBasis}"><a class="docstring-binding" href="#ParametricDFT.basis_to_dict-Tuple{EntangledQFTBasis}"><code>ParametricDFT.basis_to_dict</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">basis_to_dict(basis::EntangledQFTBasis) -&gt; Dict</code></pre><p>Convert an EntangledQFTBasis to a dictionary for custom serialization.</p><p><strong>Returns</strong></p><ul><li><code>Dict</code>: Dictionary representation of the basis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/serialization.jl#L281-L288">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.basis_to_dict-Tuple{QFTBasis}"><a class="docstring-binding" href="#ParametricDFT.basis_to_dict-Tuple{QFTBasis}"><code>ParametricDFT.basis_to_dict</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">basis_to_dict(basis::AbstractSparseBasis) -&gt; Dict</code></pre><p>Convert a basis to a dictionary for custom serialization.</p><p><strong>Returns</strong></p><ul><li><code>Dict</code>: Dictionary representation of the basis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/serialization.jl#L261-L268">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.compress-Tuple{AbstractSparseBasis, AbstractMatrix}"><a class="docstring-binding" href="#ParametricDFT.compress-Tuple{AbstractSparseBasis, AbstractMatrix}"><code>ParametricDFT.compress</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compress(basis::AbstractSparseBasis, image::AbstractMatrix; ratio::Float64=0.9)</code></pre><p>Compress an image using the given sparse basis.</p><p><strong>Arguments</strong></p><ul><li><code>basis::AbstractSparseBasis</code>: The trained basis to use for compression</li><li><code>image::AbstractMatrix</code>: Input image (must match basis dimensions)</li><li><code>ratio::Float64 = 0.9</code>: Compression ratio (0.9 means keep only 10% of coefficients)</li></ul><p><strong>Returns</strong></p><ul><li><code>CompressedImage</code>: Sparse representation of the image</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">basis = load_basis(&quot;trained_basis.json&quot;)
image = load_grayscale_image(&quot;photo.png&quot;)
compressed = compress(basis, image; ratio=0.95)  # Keep top 5%
save_compressed(&quot;photo.cimg&quot;, compressed)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/compression.jl#L42-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.compress_with_k-Tuple{AbstractSparseBasis, AbstractMatrix}"><a class="docstring-binding" href="#ParametricDFT.compress_with_k-Tuple{AbstractSparseBasis, AbstractMatrix}"><code>ParametricDFT.compress_with_k</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compress_with_k(basis::AbstractSparseBasis, image::AbstractMatrix; k::Int)</code></pre><p>Compress an image keeping exactly k coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>basis::AbstractSparseBasis</code>: The trained basis to use</li><li><code>image::AbstractMatrix</code>: Input image</li><li><code>k::Int</code>: Exact number of coefficients to keep</li></ul><p><strong>Returns</strong></p><ul><li><code>CompressedImage</code>: Sparse representation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/compression.jl#L92-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.compression_stats-Tuple{CompressedImage}"><a class="docstring-binding" href="#ParametricDFT.compression_stats-Tuple{CompressedImage}"><code>ParametricDFT.compression_stats</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compression_stats(compressed::CompressedImage) -&gt; NamedTuple</code></pre><p>Get statistics about the compression.</p><p><strong>Returns</strong></p><p>A named tuple with:</p><ul><li><code>original_size</code>: Original image dimensions</li><li><code>total_coefficients</code>: Total number of coefficients</li><li><code>kept_coefficients</code>: Number of non-zero coefficients kept</li><li><code>compression_ratio</code>: Ratio of discarded coefficients</li><li><code>storage_reduction</code>: Approximate storage reduction factor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/compression.jl#L324-L336">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.dict_to_basis-Tuple{Dict}"><a class="docstring-binding" href="#ParametricDFT.dict_to_basis-Tuple{Dict}"><code>ParametricDFT.dict_to_basis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dict_to_basis(d::Dict) -&gt; AbstractSparseBasis</code></pre><p>Convert a dictionary back to a basis.</p><p><strong>Arguments</strong></p><ul><li><code>d::Dict</code>: Dictionary with basis data</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractSparseBasis</code>: The reconstructed basis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/serialization.jl#L303-L313">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.entangled_qft_code-Tuple{Int64, Int64}"><a class="docstring-binding" href="#ParametricDFT.entangled_qft_code-Tuple{Int64, Int64}"><code>ParametricDFT.entangled_qft_code</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">entangled_qft_code(m::Int, n::Int; entangle_phases=nothing, inverse=false)</code></pre><p>Generate an optimized tensor network representation of the entangled QFT circuit.</p><p>The entangled QFT extends the standard 2D QFT by adding entanglement gates E<em>k between corresponding row and column qubits (x</em>k, y<em>k). Each entanglement gate E</em>k is a controlled-phase gate with the same structure as the M gate in QFT:</p><p><strong>Full gate form (4×4 matrix):</strong>     E<em>k = diag(1, 1, 1, e^(i*phi</em>k))</p><p><strong>Tensor network form (2×2 matrix):</strong>     E<em>k</em>tensor = [1 0; 0 e^(i*phi_k)]</p><p>The gate acts on qubits (x<em>{n-k}, y</em>{n-k}), where phi_k is a learnable phase parameter. In the tensor network, these are represented as 2×2 matrices.</p><p>For a square 2^n × 2^n image (m = n), we add exactly n entanglement gates, one for each pair of corresponding row/column qubits.</p><p><strong>Arguments</strong></p><ul><li><code>m::Int</code>: Number of qubits for row indices (image height = 2^m)</li><li><code>n::Int</code>: Number of qubits for column indices (image width = 2^n)</li><li><code>entangle_phases::Union{Nothing, Vector{&lt;:Real}}</code>: Initial phases for entanglement gates. If nothing, defaults to zeros (equivalent to standard QFT). Length must equal min(m, n).</li><li><code>inverse::Bool</code>: If true, generate inverse transform code</li></ul><p><strong>Returns</strong></p><ul><li><code>optcode::AbstractEinsum</code>: Optimized einsum contraction code</li><li><code>tensors::Vector</code>: Circuit parameters (unitary matrices + entanglement gates)</li><li><code>n_entangle::Int</code>: Number of entanglement gates added</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create entangled QFT for 64×64 images with default (zero) phases
optcode, tensors, n_entangle = entangled_qft_code(6, 6)

# Create with custom initial phases
phases = rand(6) * 2π
optcode, tensors, n_entangle = entangled_qft_code(6, 6; entangle_phases=phases)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/entangled_qft.jl#L44-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.entanglement_gate-Tuple{Real}"><a class="docstring-binding" href="#ParametricDFT.entanglement_gate-Tuple{Real}"><code>ParametricDFT.entanglement_gate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">entanglement_gate(phi::Real)</code></pre><p>Create the tensor network representation of a 2-qubit controlled-phase gate E with learnable phase phi.</p><p><strong>Full gate form (4×4 matrix in computational basis):</strong>     E = diag(1, 1, 1, e^(i*phi))</p><p>This applies phase e^(i*phi) only when both qubits are in state |1⟩.</p><p><strong>Tensor network form (2×2 matrix):</strong>     E_tensor = [1  0; 0  e^(i*phi)]</p><p>In the einsum tensor network decomposition, controlled-phase gates are  represented as 2×2 matrices acting on the bond indices connecting the  control and target qubits. This function returns the tensor form, not  the full 4×4 gate matrix.</p><p>This gate has the same structure as the M gate in the QFT circuit, but with a learnable phase parameter instead of the fixed QFT phases (2π/2^k).</p><p><strong>Arguments</strong></p><ul><li><code>phi::Real</code>: Phase parameter (in radians)</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{ComplexF64}</code>: 2×2 matrix in tensor network form</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/entangled_qft.jl#L8-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.extract_entangle_phases-Tuple{Any, Vector{Int64}}"><a class="docstring-binding" href="#ParametricDFT.extract_entangle_phases-Tuple{Any, Vector{Int64}}"><code>ParametricDFT.extract_entangle_phases</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_entangle_phases(tensors, entangle_indices::Vector{Int})</code></pre><p>Extract the phase parameters from entanglement gate tensors.</p><p><strong>Arguments</strong></p><ul><li><code>tensors::Vector</code>: Circuit tensors</li><li><code>entangle_indices::Vector{Int}</code>: Indices of entanglement gates</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Phase parameters phi_k for each entanglement gate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/entangled_qft.jl#L187-L198">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.fft_with_training-Tuple{Int64, Int64, Matrix, AbstractLoss}"><a class="docstring-binding" href="#ParametricDFT.fft_with_training-Tuple{Int64, Int64, Matrix, AbstractLoss}"><code>ParametricDFT.fft_with_training</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fft_with_training(m::Int, n::Int, pic::Matrix, loss::AbstractLoss; steps::Int=1000, use_cuda::Bool=false)</code></pre><p>Train a parametric 2D quantum DFT circuit using Riemannian gradient descent.</p><p><strong>Arguments</strong></p><ul><li><code>m::Int</code>: Number of qubits for row dimension (image height = 2^m)</li><li><code>n::Int</code>: Number of qubits for column dimension (image width = 2^n)</li><li><code>pic::Matrix</code>: Input signal (size must be 2^m × 2^n)</li><li><code>loss::AbstractLoss</code>: Loss function (e.g., <code>L1Norm()</code>)</li><li><code>steps::Int=1000</code>: Maximum optimization iterations</li><li><code>use_cuda::Bool=false</code>: Whether to use CUDA acceleration (not yet implemented)</li></ul><p><strong>Returns</strong></p><ul><li>Optimized parameters on the manifold (use <code>point2tensors</code> to convert to tensors)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">m, n = 6, 6  # For 64×64 image
pic = rand(ComplexF64, 2^m, 2^n)
# L1 norm loss
theta = fft_with_training(m, n, pic, L1Norm(); steps=200)
# MSE loss with truncation (keep top 100 elements)
theta = fft_with_training(m, n, pic, MSELoss(100); steps=200)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/qft.jl#L80-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.forward_transform-Tuple{EntangledQFTBasis, AbstractMatrix}"><a class="docstring-binding" href="#ParametricDFT.forward_transform-Tuple{EntangledQFTBasis, AbstractMatrix}"><code>ParametricDFT.forward_transform</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forward_transform(basis::EntangledQFTBasis, image::AbstractMatrix)</code></pre><p>Apply forward entangled QFT transform to convert image to frequency domain.</p><p><strong>Arguments</strong></p><ul><li><code>basis::EntangledQFTBasis</code>: The basis to use for transformation</li><li><code>image::AbstractMatrix</code>: Input image (must be size 2^m × 2^n)</li></ul><p><strong>Returns</strong></p><ul><li>Frequency domain representation (Complex matrix of same size)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L343-L354">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.forward_transform-Tuple{QFTBasis, AbstractMatrix}"><a class="docstring-binding" href="#ParametricDFT.forward_transform-Tuple{QFTBasis, AbstractMatrix}"><code>ParametricDFT.forward_transform</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forward_transform(basis::QFTBasis, image::AbstractMatrix)</code></pre><p>Apply forward transform to convert image to frequency domain.</p><p><strong>Arguments</strong></p><ul><li><code>basis::QFTBasis</code>: The basis to use for transformation</li><li><code>image::AbstractMatrix</code>: Input image (must be size 2^m × 2^n)</li></ul><p><strong>Returns</strong></p><ul><li>Frequency domain representation (Complex matrix of same size)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L99-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.ft_mat-Tuple{Vector, OMEinsum.AbstractEinsum, Int64, Int64, Matrix}"><a class="docstring-binding" href="#ParametricDFT.ft_mat-Tuple{Vector, OMEinsum.AbstractEinsum, Int64, Int64, Matrix}"><code>ParametricDFT.ft_mat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ft_mat(tensors::Vector, code::AbstractEinsum, m::Int, n::Int, pic::Matrix)</code></pre><p>Apply 2D DFT to an image using the trained circuit parameters.</p><p><strong>Arguments</strong></p><ul><li><code>tensors::Vector</code>: Circuit tensors (unitary matrices)</li><li><code>code::AbstractEinsum</code>: Optimized einsum code</li><li><code>m::Int</code>: Number of qubits for row dimension</li><li><code>n::Int</code>: Number of qubits for column dimension</li><li><code>pic::Matrix</code>: Input image (size 2^m × 2^n)</li></ul><p><strong>Returns</strong></p><ul><li>Transformed image in frequency domain (size 2^m × 2^n)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/qft.jl#L133-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.generate_manifold-Tuple{Any}"><a class="docstring-binding" href="#ParametricDFT.generate_manifold-Tuple{Any}"><code>ParametricDFT.generate_manifold</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_manifold(tensors)</code></pre><p>Generate product manifold for m+n-qubit QFT parameters. Returns a product of U(2) manifolds for Hadamard gates and U(1)^4 for controlled gates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/qft.jl#L41-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.get_entangle_phases-Tuple{EntangledQFTBasis}"><a class="docstring-binding" href="#ParametricDFT.get_entangle_phases-Tuple{EntangledQFTBasis}"><code>ParametricDFT.get_entangle_phases</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_entangle_phases(basis::EntangledQFTBasis)</code></pre><p>Get the current entanglement phase parameters.</p><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Phase parameters phi_k for each entanglement gate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L433-L440">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.get_entangle_tensor_indices-Tuple{Any, Int64}"><a class="docstring-binding" href="#ParametricDFT.get_entangle_tensor_indices-Tuple{Any, Int64}"><code>ParametricDFT.get_entangle_tensor_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_entangle_tensor_indices(tensors, n_entangle::Int)</code></pre><p>Identify which tensors in the circuit correspond to entanglement gates. Returns the indices of the entanglement gate tensors (the last n_entangle controlled-phase gates).</p><p>In the tensor network representation from yao2einsum, controlled-phase gates have the form [1, 1; 1, e^(i*phi)] (not diagonal). The entanglement gates are the last n_entangle such tensors after sorting (Hadamards first, then phase gates).</p><p>After training, tensors may drift slightly from the exact pattern, so we use tolerance-based magnitude checks.</p><p><strong>Arguments</strong></p><ul><li><code>tensors::Vector</code>: Circuit tensors</li><li><code>n_entangle::Int</code>: Number of entanglement gates</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Int}</code>: Indices of entanglement gate tensors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/entangled_qft.jl#L144-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.get_manifold-Tuple{EntangledQFTBasis}"><a class="docstring-binding" href="#ParametricDFT.get_manifold-Tuple{EntangledQFTBasis}"><code>ParametricDFT.get_manifold</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_manifold(basis::EntangledQFTBasis)</code></pre><p>Get the product manifold for Riemannian optimization of basis parameters.</p><p><strong>Returns</strong></p><ul><li><code>ProductManifold</code>: Manifold structure for the tensors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L464-L471">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.get_manifold-Tuple{QFTBasis}"><a class="docstring-binding" href="#ParametricDFT.get_manifold-Tuple{QFTBasis}"><code>ParametricDFT.get_manifold</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_manifold(basis::QFTBasis)</code></pre><p>Get the product manifold for Riemannian optimization of basis parameters.</p><p><strong>Returns</strong></p><ul><li><code>ProductManifold</code>: Manifold structure for the tensors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L200-L207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.ift_mat-Tuple{Vector, OMEinsum.AbstractEinsum, Int64, Int64, Matrix}"><a class="docstring-binding" href="#ParametricDFT.ift_mat-Tuple{Vector, OMEinsum.AbstractEinsum, Int64, Int64, Matrix}"><code>ParametricDFT.ift_mat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ift_mat(tensors::Vector, code::AbstractEinsum, m::Int, n::Int, pic::Matrix)</code></pre><p>Apply inverse 2D DFT using the inverse QFT circuit with trained parameters.</p><p><strong>Arguments</strong></p><ul><li><code>tensors::Vector</code>: Circuit tensors (unitary matrices) from inverse QFT (use qft_code(m, n; inverse=true))</li><li><code>code::AbstractEinsum</code>: Optimized einsum code from inverse QFT</li><li><code>m::Int</code>: Number of qubits for row dimension</li><li><code>n::Int</code>: Number of qubits for column dimension</li><li><code>pic::Matrix</code>: Input in frequency domain (size 2^m × 2^n)</li></ul><p><strong>Returns</strong></p><ul><li>Transformed image in spatial domain (size 2^m × 2^n)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/qft.jl#L153-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.image_size-Tuple{EntangledQFTBasis}"><a class="docstring-binding" href="#ParametricDFT.image_size-Tuple{EntangledQFTBasis}"><code>ParametricDFT.image_size</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">image_size(basis::EntangledQFTBasis)</code></pre><p>Return the supported image dimensions for this basis.</p><p><strong>Returns</strong></p><ul><li><code>Tuple{Int,Int}</code>: (height, width) = (2^m, 2^n)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L389-L396">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.image_size-Tuple{QFTBasis}"><a class="docstring-binding" href="#ParametricDFT.image_size-Tuple{QFTBasis}"><code>ParametricDFT.image_size</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">image_size(basis::QFTBasis)</code></pre><p>Return the supported image dimensions for this basis.</p><p><strong>Returns</strong></p><ul><li><code>Tuple{Int,Int}</code>: (height, width) = (2^m, 2^n)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L148-L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.inverse_transform-Tuple{EntangledQFTBasis, AbstractMatrix}"><a class="docstring-binding" href="#ParametricDFT.inverse_transform-Tuple{EntangledQFTBasis, AbstractMatrix}"><code>ParametricDFT.inverse_transform</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inverse_transform(basis::EntangledQFTBasis, freq_domain::AbstractMatrix)</code></pre><p>Apply inverse entangled QFT transform to convert frequency domain back to image.</p><p><strong>Arguments</strong></p><ul><li><code>basis::EntangledQFTBasis</code>: The basis to use for transformation</li><li><code>freq_domain::AbstractMatrix</code>: Frequency domain data (size 2^m × 2^n)</li></ul><p><strong>Returns</strong></p><ul><li>Reconstructed image (Complex matrix of same size)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L367-L378">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.inverse_transform-Tuple{QFTBasis, AbstractMatrix}"><a class="docstring-binding" href="#ParametricDFT.inverse_transform-Tuple{QFTBasis, AbstractMatrix}"><code>ParametricDFT.inverse_transform</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inverse_transform(basis::QFTBasis, freq_domain::AbstractMatrix)</code></pre><p>Apply inverse transform to convert frequency domain back to image.</p><p><strong>Arguments</strong></p><ul><li><code>basis::QFTBasis</code>: The basis to use for transformation</li><li><code>freq_domain::AbstractMatrix</code>: Frequency domain data (size 2^m × 2^n)</li></ul><p><strong>Returns</strong></p><ul><li>Reconstructed image (Complex matrix of same size)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L125-L136">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.load_basis-Tuple{String}"><a class="docstring-binding" href="#ParametricDFT.load_basis-Tuple{String}"><code>ParametricDFT.load_basis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_basis(path::String) -&gt; AbstractSparseBasis</code></pre><p>Load a sparse basis from a JSON file.</p><p><strong>Arguments</strong></p><ul><li><code>path::String</code>: Path to the JSON file</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractSparseBasis</code>: The loaded basis (concrete type depends on file contents)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">basis = load_basis(&quot;trained_basis.json&quot;)
freq = forward_transform(basis, image)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/serialization.jl#L132-L148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.load_compressed-Tuple{String}"><a class="docstring-binding" href="#ParametricDFT.load_compressed-Tuple{String}"><code>ParametricDFT.load_compressed</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_compressed(path::String) -&gt; CompressedImage</code></pre><p>Load a compressed image from a JSON file.</p><p><strong>Arguments</strong></p><ul><li><code>path::String</code>: Path to the compressed image file</li></ul><p><strong>Returns</strong></p><ul><li><code>CompressedImage</code>: The loaded compressed image</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/compression.jl#L292-L302">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.loss_function-Tuple{AbstractVector, Int64, Int64, OMEinsum.AbstractEinsum, Matrix, AbstractLoss}"><a class="docstring-binding" href="#ParametricDFT.loss_function-Tuple{AbstractVector, Int64, Int64, OMEinsum.AbstractEinsum, Matrix, AbstractLoss}"><code>ParametricDFT.loss_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">loss_function(tensors, m::Int, n::Int, optcode::AbstractEinsum, pic::Matrix, loss::AbstractLoss; inverse_code=nothing)</code></pre><p>Compute the loss for current circuit parameters.</p><p><strong>Arguments</strong></p><ul><li><code>tensors::Vector</code>: Circuit parameters (unitary matrices)</li><li><code>m::Int</code>: Number of qubits for row dimension</li><li><code>n::Int</code>: Number of qubits for column dimension</li><li><code>optcode::AbstractEinsum</code>: Optimized einsum code (forward transform)</li><li><code>pic::Matrix</code>: Input signal (size must be 2^m × 2^n)</li><li><code>loss::AbstractLoss</code>: Loss function type</li><li><code>inverse_code::AbstractEinsum</code>: Optional inverse einsum code (required for MSELoss)</li></ul><p><strong>Returns</strong></p><ul><li>Loss value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/loss.jl#L147-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.num_entangle_parameters-Tuple{EntangledQFTBasis}"><a class="docstring-binding" href="#ParametricDFT.num_entangle_parameters-Tuple{EntangledQFTBasis}"><code>ParametricDFT.num_entangle_parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">num_entangle_parameters(basis::EntangledQFTBasis)</code></pre><p>Return the number of entanglement phase parameters.</p><p><strong>Returns</strong></p><ul><li><code>Int</code>: Number of entanglement gates (= min(m, n))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L421-L428">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.num_parameters-Tuple{EntangledQFTBasis}"><a class="docstring-binding" href="#ParametricDFT.num_parameters-Tuple{EntangledQFTBasis}"><code>ParametricDFT.num_parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">num_parameters(basis::EntangledQFTBasis)</code></pre><p>Return the total number of learnable parameters in the basis.</p><p>For EntangledQFTBasis:</p><ul><li>Standard QFT parameters (Hadamard gates + M gates)</li><li>Additional n entanglement gate phases (one per qubit pair)</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Total parameter count</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L401-L412">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.num_parameters-Tuple{QFTBasis}"><a class="docstring-binding" href="#ParametricDFT.num_parameters-Tuple{QFTBasis}"><code>ParametricDFT.num_parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">num_parameters(basis::QFTBasis)</code></pre><p>Return the total number of learnable parameters in the basis.</p><p>For QFT basis:</p><ul><li>n Hadamard gates: 4n parameters each (2×2 unitary)</li><li>n(n-1)/2 controlled-phase gates: 4 parameters each (diagonal 2×2)</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Total parameter count</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/basis.jl#L160-L171">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.point2tensors-Tuple{Any, Any}"><a class="docstring-binding" href="#ParametricDFT.point2tensors-Tuple{Any, Any}"><code>ParametricDFT.point2tensors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">point2tensors(p, M)</code></pre><p>Convert a manifold point back to circuit tensors (unitary matrices).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/qft.jl#L67-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.qft_code-Tuple{Int64, Int64}"><a class="docstring-binding" href="#ParametricDFT.qft_code-Tuple{Int64, Int64}"><code>ParametricDFT.qft_code</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">qft_code(m::Int, n::Int; inverse=false)</code></pre><p>Generate an optimized tensor network representation of the QFT circuit.</p><p><strong>Arguments</strong></p><ul><li><code>m::Int</code>: Number of qubits for row indices</li><li><code>n::Int</code>: Number of qubits for column indices</li><li><code>inverse::Bool</code>: If true, generate inverse transform code</li></ul><p><strong>Returns</strong></p><ul><li><code>optcode::AbstractEinsum</code>: Optimized einsum contraction code</li><li><code>tensors::Vector</code>: Initial circuit parameters (unitary matrices)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/qft.jl#L6-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.recover-Tuple{AbstractSparseBasis, CompressedImage}"><a class="docstring-binding" href="#ParametricDFT.recover-Tuple{AbstractSparseBasis, CompressedImage}"><code>ParametricDFT.recover</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">recover(basis::AbstractSparseBasis, compressed::CompressedImage; verify_hash::Bool=true)</code></pre><p>Recover an image from its compressed representation.</p><p><strong>Arguments</strong></p><ul><li><code>basis::AbstractSparseBasis</code>: The basis used for compression</li><li><code>compressed::CompressedImage</code>: The compressed image data</li><li><code>verify_hash::Bool = true</code>: Whether to verify basis hash matches</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: Reconstructed image (real-valued)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">basis = load_basis(&quot;trained_basis.json&quot;)
compressed = load_compressed(&quot;photo.cimg&quot;)
recovered = recover(basis, compressed)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/compression.jl#L173-L192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.save_basis-Tuple{String, AbstractSparseBasis}"><a class="docstring-binding" href="#ParametricDFT.save_basis-Tuple{String, AbstractSparseBasis}"><code>ParametricDFT.save_basis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save_basis(path::String, basis::AbstractSparseBasis)</code></pre><p>Save a sparse basis to a JSON file.</p><p><strong>Arguments</strong></p><ul><li><code>path::String</code>: File path to save to (should end in .json)</li><li><code>basis::AbstractSparseBasis</code>: The basis to save</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">basis = train_basis(QFTBasis, images; m=6, n=6)
save_basis(&quot;trained_basis.json&quot;, basis)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/serialization.jl#L48-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.save_compressed-Tuple{String, CompressedImage}"><a class="docstring-binding" href="#ParametricDFT.save_compressed-Tuple{String, CompressedImage}"><code>ParametricDFT.save_compressed</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save_compressed(path::String, compressed::CompressedImage)</code></pre><p>Save a compressed image to a JSON file.</p><p><strong>Arguments</strong></p><ul><li><code>path::String</code>: File path to save to</li><li><code>compressed::CompressedImage</code>: The compressed image to save</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: The path where the file was saved</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/compression.jl#L256-L267">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.tensors2point-Tuple{Any, ManifoldsBase.ProductManifold}"><a class="docstring-binding" href="#ParametricDFT.tensors2point-Tuple{Any, ManifoldsBase.ProductManifold}"><code>ParametricDFT.tensors2point</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tensors2point(tensors, M::ProductManifold)</code></pre><p>Convert circuit tensors (unitary matrices) to a point on the product manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/qft.jl#L53-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.topk_truncate-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer}} where T"><a class="docstring-binding" href="#ParametricDFT.topk_truncate-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer}} where T"><code>ParametricDFT.topk_truncate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">topk_truncate(x::AbstractMatrix, k::Integer)</code></pre><p>Return a matrix where frequency-dependent truncation is applied for image compression. Low-frequency components (near center) are kept with higher priority, while high-frequency components (away from center) are kept with lower priority.</p><p>This is more appropriate for image compression than global top-k selection, as it preserves more low-frequency information which contains most of the image structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/loss.jl#L55-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.train_basis-Tuple{Type{EntangledQFTBasis}, Vector{&lt;:AbstractMatrix}}"><a class="docstring-binding" href="#ParametricDFT.train_basis-Tuple{Type{EntangledQFTBasis}, Vector{&lt;:AbstractMatrix}}"><code>ParametricDFT.train_basis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">train_basis(::Type{EntangledQFTBasis}, dataset::Vector{&lt;:AbstractMatrix}; kwargs...)</code></pre><p>Train an EntangledQFTBasis on a dataset of images using Riemannian gradient descent.</p><p>The EntangledQFTBasis extends the standard QFT by adding entanglement gates E<em>k between corresponding row and column qubits. Each entanglement gate has a learnable phase parameter phi</em>k.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{EntangledQFTBasis}</code>: The basis type to train</li><li><code>dataset::Vector{&lt;:AbstractMatrix}</code>: Training images (each must be 2^m × 2^n)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>m::Int</code>: Number of qubits for rows (image height = 2^m)</li><li><code>n::Int</code>: Number of qubits for columns (image width = 2^n)</li><li><code>entangle_phases::Union{Nothing, Vector{&lt;:Real}}</code>: Initial phases for entanglement gates. If nothing, defaults to zeros.</li><li><code>loss::AbstractLoss = MSELoss(k)</code>: Loss function for training</li><li><code>epochs::Int = 3</code>: Number of training epochs</li><li><code>steps_per_image::Int = 200</code>: Gradient descent steps per image</li><li><code>validation_split::Float64 = 0.2</code>: Fraction of data for validation</li><li><code>shuffle::Bool = true</code>: Whether to shuffle data each epoch</li><li><code>early_stopping_patience::Int = 2</code>: Epochs without improvement before stopping</li><li><code>verbose::Bool = true</code>: Whether to print training progress</li></ul><p><strong>Returns</strong></p><ul><li><code>EntangledQFTBasis</code>: Trained basis with optimized parameters including entanglement phases</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Load images as matrices
images = [load_image(path) for path in image_paths]

# Train entangled basis for 64×64 images with 90% compression
k = round(Int, 64 * 64 * 0.1)  # Keep 10% of coefficients
basis = train_basis(EntangledQFTBasis, images; m=6, n=6, loss=MSELoss(k), epochs=5)

# The trained basis will have optimized entanglement phases
phases = get_entangle_phases(basis)

# Save the trained basis
save_basis(&quot;entangled_basis.json&quot;, basis)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/training.jl#L182-L226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.train_basis-Tuple{Type{QFTBasis}, Vector{&lt;:AbstractMatrix}}"><a class="docstring-binding" href="#ParametricDFT.train_basis-Tuple{Type{QFTBasis}, Vector{&lt;:AbstractMatrix}}"><code>ParametricDFT.train_basis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">train_basis(::Type{QFTBasis}, dataset::Vector{&lt;:AbstractMatrix}; kwargs...)</code></pre><p>Train a QFTBasis on a dataset of images using Riemannian gradient descent.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{QFTBasis}</code>: The basis type to train</li><li><code>dataset::Vector{&lt;:AbstractMatrix}</code>: Training images (each must be 2^m × 2^n)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>m::Int</code>: Number of qubits for rows (image height = 2^m)</li><li><code>n::Int</code>: Number of qubits for columns (image width = 2^n)</li><li><code>loss::AbstractLoss = MSELoss(k)</code>: Loss function for training</li><li><code>epochs::Int = 3</code>: Number of training epochs</li><li><code>steps_per_image::Int = 200</code>: Gradient descent steps per image</li><li><code>validation_split::Float64 = 0.2</code>: Fraction of data for validation</li><li><code>shuffle::Bool = true</code>: Whether to shuffle data each epoch</li><li><code>early_stopping_patience::Int = 2</code>: Epochs without improvement before stopping</li><li><code>verbose::Bool = true</code>: Whether to print training progress</li></ul><p><strong>Returns</strong></p><ul><li><code>QFTBasis</code>: Trained basis with optimized parameters</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Load images as matrices
images = [load_image(path) for path in image_paths]

# Train basis for 64×64 images with 90% compression
k = round(Int, 64 * 64 * 0.1)  # Keep 10% of coefficients
basis = train_basis(QFTBasis, images; m=6, n=6, loss=MSELoss(k), epochs=5)

# Save the trained basis
save_basis(&quot;trained_basis.json&quot;, basis)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/training.jl#L7-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParametricDFT.train_basis_from_files"><a class="docstring-binding" href="#ParametricDFT.train_basis_from_files"><code>ParametricDFT.train_basis_from_files</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">train_basis_from_files(::Type{QFTBasis}, image_paths::Vector{String}; 
                      target_size::Int, kwargs...)</code></pre><p>Train a QFTBasis from image files, automatically resizing to power-of-2 dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{QFTBasis}</code>: The basis type to train</li><li><code>image_paths::Vector{String}</code>: Paths to image files</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>target_size::Int</code>: Target size (must be power of 2, e.g., 64, 128, 256, 512)</li><li><code>kwargs...</code>: Additional arguments passed to <code>train_basis</code></li></ul><p><strong>Returns</strong></p><ul><li><code>QFTBasis</code>: Trained basis</li></ul><p><strong>Note</strong></p><p>This function requires the Images.jl package to be loaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nzy1997/ParametricDFT.jl/blob/0008c1f92c1b745601aec6dab938bed624f9eb60/src/training.jl#L473-L492">source</a></section></details></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 13 January 2026 08:08">Tuesday 13 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
